// Race data and hidden factors
class UmaMusumeTracker {
    constructor() {
        this.races = [];
        this.hiddenFactors = [];
        this.selectedRaces = new Set();
        this.wonRaces = new Set();
        this.lostRaces = new Set();
        this.currentFilter = 'all';
		// Planner state (game-like UI)
		this.plannerYear = 'junior'; // 'junior' | 'classics' | 'senior'
		this.monthOrder = ['January','February','March','April','May','June','July','August','September','October','November','December'];
		this.halfOrder = ['1st','2nd'];
		this.plannerData = this.createEmptyPlannerData();
        
        this.initializeData();
        this.setupEventListeners();
        this.renderRaces();
		this.renderPlannerGrid();
        this.updateProgress();
        // Sync progress panel height with planner after initial render
        setTimeout(() => this.syncProgressHeightToPlanner(), 0);
    }

    initializeData() {
        // Distance categories (in meters)
        this.distanceCategories = {
            short: race => parseInt(race.length.replace(/[^\d]/g, '')) <= 1400,
            mile: race => {
                const length = parseInt(race.length.replace(/[^\d]/g, ''));
                return length >= 1500 && length <= 1700;
            },
            medium: race => {
                const length = parseInt(race.length.replace(/[^\d]/g, ''));
                return length >= 1800 && length <= 2200;
            },
            long: race => parseInt(race.length.replace(/[^\d]/g, '')) >= 2300
        };

        // Eastern Japan tracks
        this.easternTracks = ['Tokyo', 'Nakayama (Chiba)', 'Niigata', 'Fukushima', 'Kawasaki', 'Ooi', 'Funabashi', 'Morioka'];
        
        // Western Japan tracks  
        this.westernTracks = ['Kyoto', 'Hanshin (Takarazuka)', 'Chukyou (Nagoya)', 'Kokura (Kitakyushu)', 'Sapporo', 'Hakodate'];

        // JRA Summer Series groupings (dataset-aligned names)
        this.summerSeries = {
            sprint: [
                'Hakodate Sprint Stakes',
                'CBC Sho',
                'Ibis Summer Dash',
                'Keeneland Cup',
                'Kitakyushu Kinen',
                'Centaur Stakes'
            ],
            mile: [
                // Official series includes Epsom Cup (1800m) alongside mile-targeted handicaps
                'Epsom Cup',
                'Chukyo Kinen',
                'Sekiya Kinen'
            ],
            s2000: [
                'Hakodate Kinen',
                'Tanabata Sho',
                'Kokura Kinen',
                'Sapporo Kinen',
                'Niigata Kinen'
            ]
        };

        // Translation maps
        this.translations = {
            tracks: {
                'Tokyo': '東京',
                'Nakayama (Chiba)': '中山',
                'Kyoto': '京都',
                'Hanshin (Takarazuka)': '阪神',
                'Chukyou (Nagoya)': '中京',
                'Kokura (Kitakyushu)': '小倉',
                'Sapporo': '札幌',
                'Hakodate': '函館',
                'Niigata': '新潟',
                'Fukushima': '福島',
                'Kawasaki': '川崎',
                'Ooi': '大井',
                'Funabashi': '船橋',
                'Morioka': '盛岡'
            },
            surfaces: {
                'turf': '芝',
                'dirt': 'ダート'
            },
            months: {
                'January': '1月',
                'February': '2月',
                'March': '3月',
                'April': '4月',
                'May': '5月',
                'June': '6月',
                'July': '7月',
                'August': '8月',
                'September': '9月',
                'October': '10月',
                'November': '11月',
                'December': '12月'
            },
            halves: {
                '1st': '前半',
                '2nd': '後半'
            },
            directions: {
                'right': '右回り',
                'left': '左回り'
            },
            seasons: {
                'spring': '春',
                'summer': '夏',
                'autumn': '秋',
                'winter': '冬'
            },
            types: {
                'Classic': 'クラシック級',
                'Senior': 'シニア級', 
                'Junior': 'ジュニア級'
            }
        };

        // Load race data
        this.loadRaceData();
        
        // Load hidden factors
        this.loadHiddenFactors();
    }

    loadRaceData() {
        // Prefer prebuilt dataset if available (generated by generate_races_js.py)
        if (typeof window !== 'undefined' && window.RACES && Array.isArray(window.RACES)) {
            this.races = window.RACES;
            // Update data source indicator
            const ind = document.getElementById('data-source-indicator');
            if (ind) {
                const meta = (typeof window !== 'undefined' && window.RACES_META) ? window.RACES_META : null;
                const dateText = meta && meta.generatedAt ? new Date(meta.generatedAt).toLocaleString() : 'unknown time';
                const countText = meta && meta.count != null ? ` (${meta.count} races)` : '';
                ind.textContent = `Data source: races.js — generated ${dateText}${countText}`;
            }
            return;
        }
        // Fallback: parse embedded sample CSV
        this.races = this.parseCSVData();
        const ind = document.getElementById('data-source-indicator');
        if (ind) {
            ind.textContent = 'Data source: embedded fallback dataset (sample)';
        }
    }

    parseCSVData() {
        // CSV data from RaceComplete.csv - representative sample
        const csvData = `函館ジュニアステークス,Hakodate Junior Stakes,6月後半,1年目,ジュニア,,,G3,函館,芝,1200m,短距離,右,,,
中京ジュニアステークス,Chukyo Junior Stakes,7月後半,1年目,ジュニア,,,OP,中京,芝,1600m,マイル,左,,,
朝日杯フューチュリティステークス,Asahi Hai Futurity Stakes,12月前半,1年目,ジュニア,,,G1,阪神,芝,1600m,マイル,右,外,,
阪神ジュベナイルフィリーズ,Hanshin Juvenile Fillies,12月前半,1年目,ジュニア,,,G1,阪神,芝,1600m,マイル,右,外,,
ホープフルステークス,Hopeful Stakes,12月後半,1年目,ジュニア,,,G1,中山,芝,2000m,中距離,右,内,,
京成杯,Keisei Hai,1月前半,2年目,,クラシック,,G3,中山,芝,2000m,中距離,右,内,,
フェアリーステークス,Fairy Stakes,1月前半,2年目,,クラシック,,G3,中山,芝,1600m,マイル,右,外,,
シンザン記念,Shinzan Kinen,1月前半,2年目,,クラシック,,G3,京都,芝,1600m,マイル,右,外,,
皐月賞,Satsuki Sho,4月前半,2年目,,クラシック,,G1,中山,芝,2000m,中距離,右,内,,
桜花賞,Oka Sho,4月前半,2年目,,クラシック,,G1,阪神,芝,1600m,マイル,右,外,,
NHKマイルカップ,NHK Mile Cup,5月前半,2年目,,クラシック,,G1,東京,芝,1600m,マイル,左,,,
日本ダービー,Japan Derby,5月後半,2年目,,クラシック,,G1,東京,芝,2400m,中距離,左,,,
オークス,Oaks,5月後半,2年目,,クラシック,,G1,東京,芝,2400m,中距離,左,,,
安田記念,Yasuda Kinen,6月前半,2年目,,クラシック,シニア,G1,東京,芝,1600m,マイル,左,,,
宝塚記念,Takarazuka Kinen,6月後半,2年目,,クラシック,シニア,G1,阪神,芝,2200m,中距離,右,内,,
スプリンターズステークス,Sprinters Stakes,9月後半,2年目,,クラシック,シニア,G1,中山,芝,1200m,短距離,右,外,,
神戸新聞杯,Kobe Shimbun Hai,9月後半,2年目,,クラシック,,G2,阪神,芝,2400m,中距離,右,外,,
菊花賞,Kikka Sho,10月後半,2年目,,クラシック,,G1,京都,芝,3000m,長距離,右,外,,
秋華賞,Akika Sho,10月後半,2年目,,クラシック,,G1,京都,芝,2000m,中距離,右,内,,
天皇賞（秋）,Tenno Sho (Autumn),10月後半,2年目,,クラシック,シニア,G1,東京,芝,2000m,中距離,左,,,
エリザベス女王杯,Queen Elizabeth II Cup,11月前半,2年目,,クラシック,シニア,G1,京都,芝,2200m,中距離,右,外,,
ジャパンカップ,Japan Cup,11月後半,2年目,,クラシック,シニア,G1,東京,芝,2400m,中距離,左,,,
マイルチャンピオンシップ,Mile Championship,11月後半,2年目,,クラシック,シニア,G1,京都,芝,1600m,マイル,右,外,,
チャンピオンズカップ,Champions Cup,12月前半,2年目,,クラシック,シニア,G1,中京,ダート,1800m,マイル,左,,,
有馬記念,Arima Kinen,12月後半,2年目,,クラシック,シニア,G1,中山,芝,2500m,長距離,右,内,,
京都金杯,Kyoto Kinen,1月前半,3年目,,,シニア,G3,京都,芝,1600m,マイル,右,外,,
中山金杯,Nakayama Kinen,1月前半,3年目,,,シニア,G3,中山,芝,2000m,中距離,右,内,,
東京新聞杯,Tokyo Shimbun Hai,2月前半,3年目,,,シニア,G3,東京,芝,1600m,マイル,左,,,
フェブラリーステークス,February Stakes,2月後半,3年目,,,シニア,G1,東京,ダート,1600m,マイル,左,,,
高松宮記念,Takamatsunomiya Kinen,3月後半,3年目,,,シニア,G1,中京,芝,1200m,短距離,左,,,
大阪杯,Osaka Hai,3月後半,3年目,,,シニア,G1,阪神,芝,2000m,中距離,右,内,,
天皇賞（春）,Tenno Sho (Spring),4月後半,3年目,,,シニア,G1,京都,芝,3200m,長距離,右,外,,
ヴィクトリアマイル,Victoria Mile,5月前半,3年目,,,シニア,G1,東京,芝,1600m,マイル,左,,,
帝王賞,Teioh Sho,6月後半,3年目,,,シニア,G1,大井,ダート,2000m,中距離,右,,,
プロキオンステークス,Procyon Stakes,7月前半,3年目,,クラシック,シニア,G3,中京,ダート,1400m,短距離,左,,,
カペラステークス,Capella Stakes,12月前半,3年目,,クラシック,シニア,G3,中山,ダート,1200m,短距離,右,,,
セントウルステークス,Centaur Stakes,9月前半,3年目,,クラシック,シニア,G2,阪神,芝,1200m,短距離,右,内,,
ダイヤモンドステークス,Diamond Stakes,2月後半,3年目,,,シニア,G3,東京,芝,3400m,長距離,左,,,
ターコイズステークス,Turquoise Stakes,12月前半,3年目,,クラシック,シニア,G3,中山,芝,1600m,マイル,右,外,,
シルクロードステークス,Silk Road Stakes,1月後半,3年目,,,シニア,G3,京都,芝,1200m,短距離,右,内,,
オーシャンステークス,Ocean Stakes,3月前半,3年目,,,シニア,G3,中山,芝,1200m,短距離,右,外,,
アルデバランステークス,Aldebaran Stakes,2月前半,3年目,,,シニア,OP,京都,ダート,1900m,中距離,右,,,
リゲルステークス,Rigel Stakes,12月前半,3年目,,クラシック,シニア,OP,阪神,芝,1600m,マイル,右,外,,
ベテルギウスステークス,Betelgeuse Stakes,12月後半,3年目,,クラシック,シニア,OP,阪神,ダート,1800m,マイル,右,,,
京都新聞杯,Kyoto Shimbun Hai,5月前半,2年目,,クラシック,,G2,京都,芝,2200m,中距離,右,外,,
中日新聞杯,Chunichi Shimbun Hai,12月前半,3年目,,クラシック,シニア,G3,中京,芝,2000m,中距離,左,,,
弥生賞,Yayoi Sho,3月前半,2年目,,クラシック,,G2,中山,芝,2000m,中距離,右,内,,
スプリングステークス,Spring Stakes,3月後半,2年目,,クラシック,,G2,中山,芝,1800m,マイル,右,内,,
セントライト記念,Saint Lite Kinen,9月後半,2年目,,クラシック,,G2,中山,芝,2200m,中距離,右,外,,
チューリップ賞,Tulip Sho,3月前半,2年目,,クラシック,,G2,阪神,芝,1600m,マイル,右,外,,
フローラステークス,Flora Stakes,4月後半,2年目,,クラシック,,G2,東京,芝,2000m,中距離,左,,,
ローズステークス,Rose Stakes,9月前半,2年目,,クラシック,,G2,阪神,芝,1800m,マイル,右,外,,
アネモネステークス,Anemone Stakes,3月前半,2年目,,クラシック,,OP,中山,芝,1600m,マイル,右,外,,,
フィリーズレビュー,Fillies Review,3月前半,2年目,,クラシック,,G2,阪神,芝,1400m,短距離,右,内,,,
若葉ステークス,Wakaba Stakes,3月後半,2年目,,クラシック,,OP,阪神,芝,2000m,中距離,右,内,,,
青葉賞,Aoba Sho,4月後半,2年目,,クラシック,,G2,東京,芝,2400m,中距離,左,,,
スイートピーステークス,Sweet Pea Stakes,4月後半,2年目,,クラシック,,OP,東京,芝,1800m,マイル,左,,,
プリンシパルステークス,Principal Stakes,5月前半,2年目,,クラシック,,OP,東京,芝,2000m,中距離,左,,,
紫苑ステークス,Shion Stakes,9月前半,2年目,,クラシック,,G3,中山,芝,2000m,中距離,右,内,,`;

        const lines = csvData.trim().split('\n');
        const races = [];
        
        // Parse each line of CSV data
        for (let i = 0; i < lines.length; i++) {
            const values = this.parseCSVLine(lines[i]);
            if (values.length >= 13) {
                const race = this.createRaceObject(values);
                if (race) {
                    races.push(race);
                }
            }
        }
        
        return races;
    }

    // Normalize grade-one detection across possible encodings (GI, G1)
    isGradeOne(race) {
        if (!race || !race.type) return false;
        const t = String(race.type).toUpperCase().replace(/\s+/g, '');
        return t === 'GI' || t === 'G1';
    }

    parseCSVLine(line) {
        return line.split(',');
    }

    createRaceObject(values) {
	        const [nameJP, nameEN, date, year, junior, classics, senior, grade, location, ground, distance, distanceCategory, direction, innerOuter, imageField, imageLink] = values;
        
        // Use English name if available, otherwise use Japanese name
        const name = nameEN.trim() || nameJP.trim();
        
        // Parse month and half from date (e.g., "6月後半" -> month: "June", half: "2nd")
        const monthHalf = this.parseDateString(date);
        
        // Convert grade format
        const type = this.convertGrade(grade);
        
        // Convert surface
        const surface = this.convertSurface(ground);
        
        // Convert track name
        const racetrack = this.convertTrackName(location);
        
        // Convert direction
        const convertedDirection = this.convertDirection(direction);
        
        // Determine season from month
        const season = this.getSeason(monthHalf.month);
        
        // Image fields (local + remote). Prefer CSV-provided link; else enrich via known mapping.
        let imageRemote = (imageLink || '').trim();
        let image = (imageField || '').trim();
        
        // If remote is present, derive local path from its filename
        if (imageRemote && !image) {
            const filename = imageRemote.split('/').pop();
            if (filename) image = `race_images/${filename}`;
        } else if (image && !image.startsWith('race_images/')) {
            // If CSV included a bare filename, prefix with local folder
            image = `race_images/${image}`;
        }
        
	        // Enrich missing remote images using a small built-in mapping for the fallback sample
        if (!imageRemote) {
            const imageRemoteByName = {
                'Hakodate Junior Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race2.png',
                'Chukyo Junior Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race1.png',
                'Asahi Hai Futurity Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race52.png',
                'Hanshin Juvenile Fillies': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race51.png',
                'Hopeful Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race55.png',
                'Keisei Hai': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race60.png',
                'Fairy Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race56.png',
                'Shinzan Kinen': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race59.png',
                'Satsuki Sho': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race83.png',
                'Oka Sho': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race82.png',
                'NHK Mile Cup': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race93.png',
                'Japan Derby': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race98.png',
                'Oaks': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race97.png',
                'Yasuda Kinen': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race102.png',
                'Takarazuka Kinen': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race112.png',
                'Sprinters Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race156.png',
                'Kobe Shimbun Hai': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race150.png',
                'Kikka Sho': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race173.png',
                'Tenno Sho (Autumn)': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race171.png',
                'Queen Elizabeth II Cup': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race179.png',
                'Japan Cup': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race190.png',
                'Mile Championship': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race189.png',
                'Champions Cup': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race201.png',
                'Arima Kinen': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race205.png',
                'Tokyo Shimbun Hai': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race224.png',
                'February Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race236.png',
                'Takamatsunomiya Kinen': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race249.png',
                'Osaka Hai': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race250.png',
                'Tenno Sho (Spring)': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race263.png',
                'Victoria Mile': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race272.png',
                'Teioh Sho': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race285.png',
                'Procyon Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race115.png',
                'Capella Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race194.png',
                'Centaur Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race142.png',
                'Diamond Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race231.png',
                'Turquoise Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race195.png',
                'Silk Road Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race219.png',
                'Ocean Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race238.png',
                'Aldebaran Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race227.png',
                'Rigel Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race198.png',
                'Betelgeuse Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race204.png',
                'Kyoto Shimbun Hai': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race94.png',
                'Chunichi Shimbun Hai': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race193.png',
                'Yayoi Sho': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race72.png',
                'Spring Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race77.png',
                'Tulip Sho': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race74.png',
                'Flora Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race89.png',
                'Rose Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race143.png',
                'Akika Sho': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race172.png',
                'Saint Lite Kinen': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race152.png',
                'Anemone Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race70.png',
                'Fillies Review': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race73.png',
                'Wakaba Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race76.png',
                'Aoba Sho': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race90.png',
                'Sweet Pea Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race88.png',
                'Principal Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race91.png',
                'Shion Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race146.png'
            };
            imageRemote = imageRemoteByName[name] || '';
            if (imageRemote && !image) {
                const filename = imageRemote.split('/').pop();
                if (filename) image = `race_images/${filename}`;
            }
        }
	        
	        // Derive year flags exclusively from Year (fallback to explicit columns if Year missing)
	        const yearStr = (year || '').trim();
	        let juniorFlag = false, classicsFlag = false, seniorFlag = false;
	        const yMatch = yearStr.match(/(\d)年目/);
	        if (yMatch) {
	            const y = parseInt(yMatch[1], 10);
	            if (y === 1) juniorFlag = true;
	            else if (y === 2) classicsFlag = true;
	            else if (y === 3) seniorFlag = true;
	        } else {
	            juniorFlag = (junior || '').trim() === 'ジュニア';
	            classicsFlag = (classics || '').trim() === 'クラシック';
	            seniorFlag = (senior || '').trim() === 'シニア';
	        }
	        
	        return {
            name: name,
            nameJP: nameJP.trim(),
            type: type,
            length: distance,
            surface: surface,
            racetrack: racetrack,
	            junior: juniorFlag,
	            classics: classicsFlag,
	            senior: seniorFlag,
            month: monthHalf.month,
            half: monthHalf.half,
            direction: convertedDirection,
            season: season,
            ...(image ? { image } : {}),
            ...(imageRemote ? { imageRemote } : {})
        };
    }

    parseDateString(dateStr) {
        const monthMap = {
            '1月': 'January', '2月': 'February', '3月': 'March', '4月': 'April',
            '5月': 'May', '6月': 'June', '7月': 'July', '8月': 'August',
            '9月': 'September', '10月': 'October', '11月': 'November', '12月': 'December'
        };
        
        const halfMap = {
            '前半': '1st',
            '後半': '2nd'
        };
        
        // Extract month and half from strings like "6月後半"
        const monthMatch = dateStr.match(/(\d+月)/);
        const halfMatch = dateStr.match(/(前半|後半)/);
        
        const month = monthMatch ? monthMap[monthMatch[1]] || 'January' : 'January';
        const half = halfMatch ? halfMap[halfMatch[1]] || '1st' : '1st';
        
        return { month, half };
    }

    convertGrade(grade) {
        const gradeMap = {
            'G1': 'GI',
            'G2': 'GII',
            'G3': 'GIII',
            'OP': 'Open',
            'Pre-OP': 'Pre-OP'
        };
        return gradeMap[grade] || grade;
    }

    convertSurface(ground) {
        const surfaceMap = {
            '芝': 'turf',
            'ダート': 'dirt'
        };
        return surfaceMap[ground] || ground;
    }

    convertTrackName(location) {
        const trackMap = {
            '東京': 'Tokyo',
            '中山': 'Nakayama (Chiba)',
            '京都': 'Kyoto',
            '阪神': 'Hanshin (Takarazuka)',
            '中京': 'Chukyou (Nagoya)',
            '小倉': 'Kokura (Kitakyushu)',
            '札幌': 'Sapporo',
            '函館': 'Hakodate',
            '新潟': 'Niigata',
            '福島': 'Fukushima',
            '川崎': 'Kawasaki',
            '大井': 'Ooi',
            '船橋': 'Funabashi',
            '盛岡': 'Morioka'
        };
        return trackMap[location] || location;
    }

    convertDirection(direction) {
        const directionMap = {
            '右': 'right',
            '左': 'left',
            '直線': 'straight'
        };
        return directionMap[direction] || direction;
    }

    getSeason(month) {
        const seasonMap = {
            'December': 'winter', 'January': 'winter', 'February': 'winter',
            'March': 'spring', 'April': 'spring', 'May': 'spring',
            'June': 'summer', 'July': 'summer', 'August': 'summer',
            'September': 'autumn', 'October': 'autumn', 'November': 'autumn'
        };
        return seasonMap[month] || 'spring';
    }

    loadHiddenFactors() {
        this.hiddenFactors = [
            {
                id: 'consecutive_wins',
                nameJP: '連戦連勝',
                nameEN: 'Consecutive Wins',
                conditionJP: '2戦連続で出走する。',
                conditionEN: 'Race 2 races in a row.',
                check: () => this.checkConsecutiveRuns()
            },
            {
                id: 'champion_east',
                nameJP: '東の雄',
                nameEN: 'Champion of the East',
                conditionJP: '東日本（東京、中山など）のG1レースで7勝以上する。',
                conditionEN: 'Win 7 or more G1 races held at tracks in eastern Japan (e.g., Tokyo, Nakayama).',
                check: () => this.checkEasternG1Wins()
            },
            {
                id: 'champion_west',
                nameJP: '西の雄',
                nameEN: 'Champion of the West',
                conditionJP: '西日本（京都、阪神など）のG1レースで7勝以上する。',
                conditionEN: 'Win 7 or more G1 races held at tracks in western Japan (e.g., Kyoto, Hanshin).',
                check: () => this.checkWesternG1Wins()
            },
            {
                id: 'traveler',
                nameJP: '旅人',
                nameEN: 'Traveler',
                conditionJP: '7種類以上のレース場に出走する（勝利は不問）。',
                conditionEN: 'Compete at 7 or more different racecourses. Winning is not a requirement.',
                check: () => this.checkDifferentRacecourses()
            },
            {
                id: 'all_ranks_conquered',
                nameJP: '全階級制覇',
                nameEN: 'All Ranks Conquered',
                conditionJP: '短距離、マイル、中距離、長距離の各距離で1回以上勝利する。',
                conditionEN: 'Win at least one race in each distance category: Short, Mile, Medium, and Long.',
                check: () => this.checkAllDistanceG1()
            },
            {
                id: 'newspaper_boy',
                nameJP: '新聞屋さん',
                nameEN: 'Newspaper Boy/Girl',
                conditionJP: '指定された4つの「新聞杯」レース（京都新聞杯、神戸新聞杯、中日新聞杯、東京新聞杯）に勝利する。',
                conditionEN: 'Win the four "Shimbun Hai" races: Kyoto, Kobe, Chunichi, and Tokyo Shimbun Hai.',
                check: () => this.checkNewspaperCups()
            },
            {
                id: 'summer_sprint_series',
                nameJP: 'SSS',
                nameEN: 'Summer Sprint Series',
                conditionJP: 'サマースプリントシリーズ対象レースから3勝する。',
                conditionEN: 'Win 3 races from the Summer Sprint Series.',
                check: () => this.checkSummerSeries('sprint')
            },
            {
                id: 'summer_mile_series',
                nameJP: 'SMS',
                nameEN: 'Summer Mile Series',
                conditionJP: 'サマーマイルシリーズ対象レースから3勝する。',
                conditionEN: 'Win 3 races from the Summer Mile Series.',
                check: () => this.checkSummerSeries('mile')
            },
            {
                id: 'summer_2000_series',
                nameJP: 'S2000',
                nameEN: 'Summer 2000 Series',
                conditionJP: 'サマー2000シリーズ対象レースから3勝する。',
                conditionEN: 'Win 3 races from the Summer 2000 Series.',
                check: () => this.checkSummerSeries('s2000')
            },
            {
                id: 'years_plan',
                nameJP: '一年の計は',
                nameEN: "The Year's Plan",
                conditionJP: 'シニア級1月前半の中山金杯か京都金杯で勝利する。',
                conditionEN: 'During the Senior year, win either the Nakayama Kinen or the Kyoto Kinen in January.',
                check: () => this.checkNewYearGold()
            },
            {
                id: 'wish_upon_star',
                nameJP: '星に願いを',
                nameEN: 'Wish Upon a Star',
                conditionJP: '指定された星・星座関連の名前を持つレースの中から3勝以上する。',
                conditionEN: 'Win 3 or more races from the designated list of star or constellation-themed races.',
                check: () => this.checkStarRaces()
            },
            {
                id: 'jewelry',
                nameJP: 'ジュエリー',
                nameEN: 'Jewelry',
                conditionJP: '指定された宝石の名前を持つレースの中から3勝以上する（同名レースの重複は不可）。',
                conditionEN: 'Win 3 or more races from the designated list of jewelry-themed races.',
                check: () => this.checkJewelryRaces()
            },
            {
                id: 'dual_wielder',
                nameJP: '二刀流',
                nameEN: 'Two-Sword Style / Dual Wielder',
                conditionJP: '芝とダートの両方のバ場適性をAにする。',
                conditionEN: "Achieve an 'A' rank aptitude for both Turf and Dirt surfaces.",
                check: () => this.checkDualSurface()
            },
            {
                id: 'perfect_crown',
                nameJP: 'パーフェクトクラウン',
                nameEN: 'Perfect Crown',
                conditionJP: '牡馬三冠レース（皐月賞、日本ダービー、菊花賞）と、各レースに対応するトライアルレース3つに勝利する。',
                conditionEN: 'Win the three Triple Crown races (Satsuki Sho, Japan Derby, Kikka Sho) AND win one trial race for each.',
                check: () => this.checkPerfectCrown()
            },
            {
                id: 'perfect_tiara',
                nameJP: 'パーフェクトティアラ',
                nameEN: 'Perfect Tiara',
                conditionJP: '牝馬三冠レース（桜花賞、オークス、秋華賞）と、各レースに対応するトライアルレース3つに勝利する。',
                conditionEN: 'Win the three Triple Tiara races (Oka Sho, Oaks, Akika Sho) AND win one trial race for each.',
                check: () => this.checkPerfectTiara()
            },
            {
                id: 'improves_with_racing',
                nameJP: '叩き良化型',
                nameEN: 'Improves with Racing',
                conditionJP: "3戦以上の連続出走。'悦楽取材'の記者イベント出現が必要（簡略化済み）",
                conditionEN: "Run 3 consecutive races; requires reporter event 'Pleasure Interview' (simplified)",
                check: () => this.checkImprovesWithRacing()
            },
            {
                id: 'never_give_up',
                nameJP: '諦めない心',
                nameEN: 'Never-Give-Up Spirit',
                conditionJP: '一度負けてから勝利する（順序判定は簡略化）。',
                conditionEN: 'Lose a race, then win a race (order simplified).',
                check: () => this.checkNeverGiveUp()
            },
            {
                id: 'rebellious_spirit',
                nameJP: '反骨精神',
                nameEN: 'Rebellious Spirit',
                conditionJP: '適性C以下のレース（距離またはバ場）で勝利する（適性判定は未実装）。',
                conditionEN: "Win a race with a 'C' rank or lower aptitude for distance or surface (aptitudes not modeled).",
                check: () => this.checkRebelliousSpirit()
            },
            {
                id: 'right_awakening',
                nameJP: '右の目覚め',
                nameEN: 'Right Awakening',
                conditionJP: '右回りのレースで6回以上勝利する。',
                conditionEN: 'Win 6 or more races on right-handed tracks.',
                check: () => this.checkDirectionalAwakening('right')
            },
            {
                id: 'left_awakening',
                nameJP: '左の目覚め',
                nameEN: 'Left Awakening',
                conditionJP: '左回りのレースで6回以上勝利する。',
                conditionEN: 'Win 6 or more races on left-handed tracks.',
                check: () => this.checkDirectionalAwakening('left')
            },
            {
                id: 'spring_awakening',
                nameJP: '春の目覚め',
                nameEN: 'Spring Awakening',
                conditionJP: '春の季節のレースで6回以上勝利する。',
                conditionEN: 'Win 6 or more races during spring.',
                check: () => this.checkSeasonalAwakening('spring')
            },
            {
                id: 'summer_awakening',
                nameJP: '夏の目覚め',
                nameEN: 'Summer Awakening',
                conditionJP: '夏の季節のレースで6回以上勝利する。',
                conditionEN: 'Win 6 or more races during summer.',
                check: () => this.checkSeasonalAwakening('summer')
            },
            {
                id: 'autumn_awakening',
                nameJP: '秋の目覚め',
                nameEN: 'Autumn Awakening',
                conditionJP: '秋の季節のレースで6回以上勝利する。',
                conditionEN: 'Win 6 or more races during autumn.',
                check: () => this.checkSeasonalAwakening('autumn')
            },
            {
                id: 'winter_awakening',
                nameJP: '冬の目覚め',
                nameEN: 'Winter Awakening',
                conditionJP: '冬の季節のレースで6回以上勝利する。',
                conditionEN: 'Win 6 or more races during winter.',
                check: () => this.checkSeasonalAwakening('winter')
            }
        ];
    }

    setupEventListeners() {
        // Filter buttons
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                this.currentFilter = e.target.dataset.filter;
                this.renderRaces();
            });
        });

        // ESC key closes the picker modal (in addition to clicking outside)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.closePicker();
            } else if (e.key === 'ArrowLeft') {
                this.navigatePicker?.(-1);
            } else if (e.key === 'ArrowRight') {
                this.navigatePicker?.(1);
            }
        });
    }

	// =============================
	// Planner (game-style) UI
	// =============================
	createEmptyPlannerData() {
		const makeYear = () => {
			const cells = {};
			this.monthOrder.forEach(month => {
				this.halfOrder.forEach(half => {
					cells[this.cellKey(month, half)] = null; // single race or null
				});
			});
			return cells;
		};
		return { junior: makeYear(), classics: makeYear(), senior: makeYear() };
	}

	cellKey(month, half) { return `${month}|${half}`; }

	setPlannerYear(yearKey) {
		if (!['junior','classics','senior'].includes(yearKey)) return;
		this.plannerYear = yearKey;
		// Toggle active tab styles if present
		['tab-junior','tab-classics','tab-senior'].forEach(id => {
			const el = document.getElementById(id);
			if (!el) return;
			el.classList.remove('active');
		});
		const map = { junior: 'tab-junior', classics: 'tab-classics', senior: 'tab-senior' };
		const active = document.getElementById(map[yearKey]);
		if (active) active.classList.add('active');
		this.renderPlannerGrid();
	}

	clearPlannerYear() {
		const yearCells = this.plannerData[this.plannerYear];
		Object.keys(yearCells).forEach(k => { yearCells[k] = null; });
		this.syncSelectionsFromPlanner();
		this.renderPlannerGrid();
		this.renderRaces();
		this.updateProgress();
	}

		renderPlannerGrid() {
		const container = document.getElementById('planner-grid');
		if (!container) return; // older HTML may not have planner UI
		const yearCells = this.plannerData[this.plannerYear];
		const t = this.translations;
		const monthLabel = (m) => `${t.months[m] || m}`; // JP
		const halfLabel = (h) => `${t.halves[h] || h}`;   // JP
		const enShort = { January:'Jan', February:'Feb', March:'Mar', April:'Apr', May:'May', June:'Jun', July:'Jul', August:'Aug', September:'Sep', October:'Oct', November:'Nov', December:'Dec' };

		const slots = [];
		this.monthOrder.forEach(month => {
			this.halfOrder.forEach(half => {
				const key = this.cellKey(month, half);
					const rawValue = yearCells[key];
					const hasAnyForSlot = this.races.some(r => r.month === month && r.half === half && !!r[this.plannerYear]);
					const selectedName = (typeof rawValue === 'string' && rawValue) ? rawValue : null;
					let slotBody = '';
					if (selectedName) {
						const r = this.races.find(rr => rr.name === selectedName);
						const primary = r ? (r.image || r.imageRemote || '') : '';
						const badgeClass = this.lostRaces.has(selectedName) ? 'badge-lost' : (this.wonRaces.has(selectedName) ? 'badge-won' : '');
						slotBody = `
							<div class=\"slot-wrapper\">
								<button class=\"slot-button ${badgeClass}\" style=\"background-image: url('${primary}')\" onclick=\"tracker.openPicker('${month}','${half}')\">
									<div class=\"slot-gradient\"></div>
									<div class=\"slot-title\">
										<div class=\"en\">${r ? r.name : selectedName}</div>
										<div class=\"jp\">${r && r.nameJP ? r.nameJP : ''}</div>
									</div>
								</button>
                                <button class=\"slot-remove\" title=\"Remove / 削除\" onclick=\"tracker.removeRaceFromPlanner('${month}','${half}')\">×</button>
                                <button class=\"loss-toggle-btn ${this.lostRaces.has(selectedName) ? 'lost' : 'won'}\" title=\"Toggle Win/Loss / 勝敗切替\" style=\"position:absolute; top:6px; left:6px;\" onclick=\"tracker.toggleWinFromPlanner('${month}','${half}')\">${this.lostRaces.has(selectedName) ? '👎' : '🏆'}</button>
							</div>
						`;
					} else {
                        slotBody = `<button class=\"planner-plus\" onclick=\"tracker.openPicker('${month}','${half}')\">＋ Add / 追加</button>`;
					}
					slots.push(`
						<div class=\"planner-slot ${!selectedName && !hasAnyForSlot ? 'disabled' : ''}\">
							<div class=\"planner-slot-head\"><span>${monthLabel(month)} ${halfLabel(half)} / <span class=\\"en\\">${enShort[month] || month} ${half}</span></span></div>
								<div class=\"planner-slot-body\">${slotBody || `<button class=\\"planner-plus ${hasAnyForSlot ? '' : 'disabled'}\\" ${hasAnyForSlot ? `onclick=\\"tracker.openPicker('${month}','${half}')\\"` : ''}>＋ Add / 追加</button>`}</div>
						</div>
					`);
			});
		});
        container.innerHTML = slots.join('');
        this.syncProgressHeightToPlanner();
	}

	openPicker(month, half) {
		this.currentPicker = { year: this.plannerYear, month, half };
		const title = document.getElementById('picker-title');
		if (title) {
			const yearMap = { junior: 'ジュニア級', classics: 'クラシック級', senior: 'シニア級' };
			title.textContent = `${yearMap[this.plannerYear]} — ${this.translations.months[month] || month} ${this.translations.halves[half] || half}`;
		}
        this.renderPickerList();
        const modal = document.getElementById('picker-modal');
        if (modal) modal.classList.remove('hidden');
        // Position side navs just outside the panel edges
        setTimeout(() => {
            const panel = document.getElementById('picker-panel');
            const leftBtn = document.querySelector('.picker-nav-left');
            const rightBtn = document.querySelector('.picker-nav-right');
            if (panel && leftBtn && rightBtn) {
                const rect = panel.getBoundingClientRect();
                const gap = 12; // distance from panel edge
                leftBtn.style.left = `${rect.left - leftBtn.offsetWidth - gap}px`;
                leftBtn.style.top = `${rect.top + rect.height / 2 - leftBtn.offsetHeight / 2}px`;
                rightBtn.style.left = `${rect.right + gap}px`;
                rightBtn.style.top = `${rect.top + rect.height / 2 - rightBtn.offsetHeight / 2}px`;
            }
        }, 0);
        // Setup swipe listeners
        this.attachPickerSwipeHandlers();
	}

	closePicker() {
		const modal = document.getElementById('picker-modal');
		if (modal) modal.classList.add('hidden');
	}

    onPickerBackdrop(evt) {
        // No longer needed, as backdrop has its own onclick to close.
        // Keeping for backward compatibility if still bound.
        if (!evt) return;
        const target = evt.target;
        if (target && (target.id === 'picker-modal' || target.classList.contains('picker-backdrop'))) {
            this.closePicker();
        }
    }

		renderPickerList() {
		const listEl = document.getElementById('picker-list');
		if (!listEl || !this.currentPicker) return;
		const { year, month, half } = this.currentPicker;
		const yearFlag = { junior: 'junior', classics: 'classics', senior: 'senior' }[year];
        const filtered = this.races.filter(r => r.month === month && r.half === half && (!!r[yearFlag]));
        const typeOrder = { 'GI': 0, 'GII': 1, 'GIII': 2, 'Open': 3, 'Pre-OP': 4 };
        const sorted = filtered.slice().sort((a, b) => {
            const ao = typeOrder[a.type] ?? 99;
            const bo = typeOrder[b.type] ?? 99;
            if (ao !== bo) return ao - bo;
            return (a.name || '').localeCompare(b.name || '');
        });
            const cellValue = this.plannerData[year][this.cellKey(month, half)];
        listEl.innerHTML = sorted.map(r => {
				const selected = cellValue === r.name;
			const primary = r.image || r.imageRemote || '';
			const onerr = (r.image && r.imageRemote) ? `onerror=\"this.onerror=null; this.src='${r.imageRemote}'\"` : '';
			return `
					<div class=\"picker-item ${selected ? 'selected' : ''}\" onclick=\"tracker.addRaceToCurrentCell('${r.name}')\">
					<img src=\"${primary}\" alt=\"\" ${onerr}>
					<div>
						<h4>${r.name}</h4>
						<div class=\"sub\">${r.nameJP || ''} ・ ${r.type} ・ ${r.length} ・ ${r.racetrack}/${this.translations.tracks[r.racetrack] || r.racetrack}</div>
					</div>
				</div>
			`;
		}).join('');
	}

    navigatePicker(direction) {
        // direction: -1 (prev half) or 1 (next half). Wrap month/half within the same year.
        if (!this.currentPicker) return;
        const { year } = this.currentPicker;
        const months = this.monthOrder;
        const halves = this.halfOrder; // ['1st','2nd']
        let mi = months.indexOf(this.currentPicker.month);
        let hi = halves.indexOf(this.currentPicker.half);
        const step = direction > 0 ? 1 : -1;
        hi += step;
        if (hi < 0) { hi = halves.length - 1; mi = (mi - 1 + months.length) % months.length; }
        if (hi >= halves.length) { hi = 0; mi = (mi + 1) % months.length; }
        this.currentPicker = { year, month: months[mi], half: halves[hi] };
        // Update title and list
        const title = document.getElementById('picker-title');
        if (title) {
            const yearMap = { junior: 'ジュニア級', classics: 'クラシック級', senior: 'シニア級' };
            title.textContent = `${yearMap[year]} — ${this.translations.months[this.currentPicker.month] || this.currentPicker.month} ${this.translations.halves[this.currentPicker.half] || this.currentPicker.half}`;
        }
        this.renderPickerList();
    }

    attachPickerSwipeHandlers() {
        const panel = document.getElementById('picker-panel');
        if (!panel) return;
        let startX = 0, startY = 0, isTouch = false;
        const onTouchStart = (e) => {
            isTouch = true;
            const t = e.touches ? e.touches[0] : e;
            startX = t.clientX; startY = t.clientY;
        };
        const onTouchEnd = (e) => {
            if (!isTouch) return;
            const t = (e.changedTouches && e.changedTouches[0]) || e;
            const dx = t.clientX - startX;
            const dy = t.clientY - startY;
            if (Math.abs(dx) > 50 && Math.abs(dy) < 40) {
                this.navigatePicker(dx < 0 ? 1 : -1);
            }
            isTouch = false;
        };
        panel.onmousedown = onTouchStart;
        panel.onmouseup = onTouchEnd;
        panel.ontouchstart = onTouchStart;
        panel.ontouchend = onTouchEnd;
    }

		addRaceToCurrentCell(raceName) {
		if (!this.currentPicker) return;
		const { year, month, half } = this.currentPicker;
		const key = this.cellKey(month, half);
			const prev = this.plannerData[year][key];
			this.plannerData[year][key] = raceName;
			// reflect global selection: remove previous if no longer planned anywhere
			if (prev && !this.isPlannedAnywhere(prev)) {
				this.selectedRaces.delete(prev);
				this.wonRaces.delete(prev);
				this.lostRaces.delete(prev);
			}
			// add new as selected and won by default
			this.selectedRaces.add(raceName);
			this.lostRaces.delete(raceName);
			this.wonRaces.add(raceName);
			this.closePicker();
			this.renderPlannerGrid();
			this.renderRaces();
			this.updateProgress();
	}

		removeRaceFromPlanner(month, half) {
		const key = this.cellKey(month, half);
			const prev = this.plannerData[this.plannerYear][key];
			this.plannerData[this.plannerYear][key] = null;
			// If previous race no longer exists in any planner cell, remove from global selections
			if (prev && !this.isPlannedAnywhere(prev)) {
				this.selectedRaces.delete(prev);
				this.wonRaces.delete(prev);
				this.lostRaces.delete(prev);
			}
		this.renderPlannerGrid();
		this.renderRaces();
		this.updateProgress();
	}

		toggleWinFromPlanner(month, half) {
			const key = this.cellKey(month, half);
			const name = this.plannerData[this.plannerYear][key];
			if (!name) return;
			// Cycle Won -> Lost -> Won
			this.toggleWin(name);
		this.renderPlannerGrid();
	}

	syncSelectionsFromPlanner() {
		// Reconstruct global selections from planner (does not include manual grid selections)
			const planned = new Set();
			Object.values(this.plannerData).forEach(yearCells => {
				Object.values(yearCells).forEach(value => { if (value) planned.add(value); });
			});
		// Remove any selection not planned
		Array.from(this.selectedRaces).forEach(n => { if (!planned.has(n)) {
			this.selectedRaces.delete(n);
			this.wonRaces.delete(n);
			this.lostRaces.delete(n);
		}});
	}

		isPlannedAnywhere(raceName) {
			return Object.values(this.plannerData).some(yearCells => {
				return Object.values(yearCells).some(value => value === raceName);
			});
		}

    planRaceIntoPlanner(race, preferYear) {
        // Decide target year: prefer the active tab if applicable; otherwise the first truthy flag
        let targetYear = null;
        const flags = ['junior','classics','senior'];
        if (preferYear && race[preferYear]) targetYear = preferYear;
        if (!targetYear) {
            for (let i = 0; i < flags.length; i++) {
                if (race[flags[i]]) { targetYear = flags[i]; break; }
            }
        }
        if (!targetYear) targetYear = this.plannerYear;
        const key = this.cellKey(race.month, race.half);
        const prev = this.plannerData[targetYear][key];
        this.plannerData[targetYear][key] = race.name;
        if (prev && !this.isPlannedAnywhere(prev)) {
            this.selectedRaces.delete(prev);
            this.wonRaces.delete(prev);
            this.lostRaces.delete(prev);
        }
    }

    removeRaceEverywhereFromPlanner(raceName) {
        Object.keys(this.plannerData).forEach(yearKey => {
            const yearCells = this.plannerData[yearKey];
            Object.keys(yearCells).forEach(cellKey => {
                if (yearCells[cellKey] === raceName) yearCells[cellKey] = null;
            });
        });
    }

    renderRaces() {
        const grid = document.getElementById('races-grid');
        const filteredRaces = this.getFilteredRaces();
        
        grid.innerHTML = filteredRaces.map(race => `
            <div class="race-card ${this.selectedRaces.has(race.name) ? 'selected' : ''} ${this.wonRaces.has(race.name) ? 'won' : ''}" 
                 data-race="${race.name}" onclick="tracker.toggleParticipation('${race.name}')">
                ${(() => {
                    const primary = race.image || race.imageRemote || '';
                    const fallback = race.image && race.imageRemote ? race.imageRemote : '';
                    if (!primary) return '';
                    const onerr = fallback ? `onerror=\"this.onerror=null; this.src='${fallback}'\"` : '';
                    return `<div class=\"race-thumb\"><img class=\"race-thumb-img\" src=\"${primary}\" alt=\"${(race.name || '').replace(/"/g, '&quot;')}\" loading=\"lazy\" ${onerr}></div>`;
                })()}
                <div class="race-name">
                    <div class="race-name-en">${race.name}</div>
                    <div class="race-name-jp">${race.nameJP}</div>
                </div>
                <div class="race-details">
                    <span class="race-grade grade-${race.type}">${race.type}</span>
                    ${race.length} • ${race.surface}/${this.translations.surfaces[race.surface] || race.surface}
                </div>
                <div class="race-details">
                    ${race.racetrack}/${this.translations.tracks[race.racetrack] || race.racetrack}
                    • ${this.translations.months[race.month] || race.month} ${this.translations.halves[race.half] || race.half} / ${race.month} ${race.half}
                    ${race.direction ? `• ${this.translations.directions[race.direction]} / ${race.direction}` : ''}
                </div>
                ${this.selectedRaces.has(race.name) ? `
                <div class="win-button-container">
                    <button class="loss-toggle-btn ${this.lostRaces.has(race.name) ? 'lost' : 'won'}" 
                            onclick="event.stopPropagation(); tracker.toggleWin('${race.name}')">
                        ${this.lostRaces.has(race.name) ? '👎' : '🏆'}
                    </button>
                </div>
                ` : ''}
            </div>
        `).join('');
        this.syncProgressHeightToPlanner();
    }

    getFilteredRaces() {
        let list;
        switch(this.currentFilter) {
            case 'GI': list = this.races.filter(r => r.type === 'GI'); break;
            case 'GII': list = this.races.filter(r => r.type === 'GII'); break;
            case 'GIII': list = this.races.filter(r => r.type === 'GIII'); break;
            case 'Open': list = this.races.filter(r => r.type === 'Open'); break;
            case 'Pre-OP': list = this.races.filter(r => r.type === 'Pre-OP'); break;
            case 'junior': list = this.races.filter(r => r.junior); break;
            case 'classic': list = this.races.filter(r => r.classics); break;
            case 'senior': list = this.races.filter(r => r.senior); break;
            case 'SSS': {
                const set = new Set(this.summerSeries?.sprint || []);
                list = this.races.filter(r => set.has(r.name));
                break;
            }
            case 'SMS': {
                const set = new Set(this.summerSeries?.mile || []);
                list = this.races.filter(r => set.has(r.name));
                break;
            }
            case 'S2000': {
                const set = new Set(this.summerSeries?.s2000 || []);
                list = this.races.filter(r => set.has(r.name));
                break;
            }
            case 'selected': list = this.races.filter(r => this.selectedRaces.has(r.name)); break;
            default: list = [...this.races];
        }
        const typeOrder = { 'GI': 0, 'GII': 1, 'GIII': 2, 'Open': 3, 'Pre-OP': 4 };
        return list.sort((a, b) => {
            const ao = typeOrder[a.type] ?? 99;
            const bo = typeOrder[b.type] ?? 99;
            if (ao !== bo) return ao - bo;
            const am = this.monthOrder.indexOf(a.month);
            const bm = this.monthOrder.indexOf(b.month);
            if (am !== bm) return am - bm;
            const halfOrder = { '1st': 0, '2nd': 1 };
            const ah = halfOrder[a.half] ?? 0;
            const bh = halfOrder[b.half] ?? 0;
            if (ah !== bh) return ah - bh;
            return (a.name || '').localeCompare(b.name || '');
        });
    }

    toggleParticipation(raceName) {
        if (this.selectedRaces.has(raceName)) {
            // Remove participation and clear all results
            this.selectedRaces.delete(raceName);
            this.wonRaces.delete(raceName);
            this.lostRaces.delete(raceName);
            // Also remove from planner wherever it appears
            this.removeRaceEverywhereFromPlanner(raceName);
        } else {
            // Add participation and automatically mark as won
            this.selectedRaces.add(raceName);
            this.wonRaces.add(raceName);
            // Also place into planner for the appropriate year/month/half
            const race = this.races.find(r => r.name === raceName);
            if (race) this.planRaceIntoPlanner(race, this.plannerYear);
        }
        this.renderRaces();
        this.renderPlannerGrid();
        this.updateProgress();
    }

    toggleWin(raceName) {
        if (!this.selectedRaces.has(raceName)) return; // Can't win/lose if not participating
        
        // Toggle between Won and Lost
        if (this.wonRaces.has(raceName)) {
            // Currently won, change to lost
            this.wonRaces.delete(raceName);
            this.lostRaces.add(raceName);
        } else if (this.lostRaces.has(raceName)) {
            // Currently lost, change to won
            this.lostRaces.delete(raceName);
            this.wonRaces.add(raceName);
        }
        this.renderRaces();
        this.renderPlannerGrid();
        this.updateProgress();
    }

    clearAll() {
        this.selectedRaces.clear();
        this.wonRaces.clear();
        this.lostRaces.clear();
        // Also clear planner across all years
        Object.keys(this.plannerData).forEach(yearKey => {
            const cells = this.plannerData[yearKey];
            Object.keys(cells).forEach(k => { cells[k] = null; });
        });
        this.renderPlannerGrid();
        this.renderRaces();
        this.updateProgress();
    }

    updateProgress() {
        // Update stats
        document.getElementById('total-races').textContent = this.selectedRaces.size;
        document.getElementById('total-wins').textContent = this.wonRaces.size;
        document.getElementById('total-losses').textContent = this.lostRaces.size;
        
        // Check all hidden factors
        const results = this.hiddenFactors.map(factor => ({
            ...factor,
            result: factor.check()
        }));
        
        const completedCount = results.filter(r => r.result.completed).length;
        document.getElementById('completed-factors').textContent = completedCount;
        
        // Render hidden factors
        this.renderHiddenFactors(results);
        this.syncProgressHeightToPlanner();
    }

    syncProgressHeightToPlanner() {
        try {
            const planner = document.getElementById('planner-section');
            const panel = document.getElementById('progress-panel');
            if (!planner || !panel) return;
            const plannerHeight = planner.getBoundingClientRect().height;
            panel.style.maxHeight = `${plannerHeight}px`;
        } catch (err) {
            // ignore
        }
    }

    renderHiddenFactors(results) {
        const container = document.getElementById('hidden-factors');
        
        container.innerHTML = results.map(factor => {
            const statusClass = factor.result.completed ? 'completed' : 
                               factor.result.progress > 0 ? 'partial' : '';
            const progressPercentage = Math.min(100, (factor.result.current / factor.result.required) * 100);
            
            return `
                <div class="factor-item ${statusClass}">
                    <div class="factor-name">
                        <div class="factor-name-en">${factor.nameEN}</div>
                        <div class="factor-name-jp">${factor.nameJP}</div>
                        ${factor.result.completed ? '<div class="completion-badge">✅</div>' : ''}
                    </div>
                    <div class="factor-condition">
                        <div class="condition-en">${factor.conditionEN || factor.condition}</div>
                        ${factor.conditionJP ? `<div class="condition-jp">${factor.conditionJP}</div>` : ''}
                    </div>
                    <div class="factor-progress">
                        <div>Progress / 進捗: ${factor.result.current}/${factor.result.required}</div>
                        ${factor.result.details ? `<div style="margin-top: 2px; font-size: 0.75rem;">• ${factor.result.details}</div>` : ''}
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progressPercentage}%"></div>
                    </div>
                </div>
            `;
        }).join('');
    }

    // Condition checking methods
    checkConsecutiveRuns() {
        // CSV-aligned: 2 consecutive races; approximated by participation count ≥ 2
        const participated = this.selectedRaces.size;
        return {
            completed: participated >= 2,
            current: Math.min(participated, 2),
            required: 2,
            progress: Math.min(100, (participated / 2) * 100),
            details: `Participated in ${participated} races (consecutive check simplified)`
        };
    }
    checkConsecutiveWins() {
        // This would need race order tracking - simplified for demo
        const wins = Array.from(this.wonRaces);
        return {
            completed: wins.length >= 2,
            current: Math.min(wins.length, 2),
            required: 2,
            progress: wins.length >= 2 ? 100 : (wins.length / 2) * 100,
            details: wins.length >= 2 ? 'Need consecutive wins (simplified)' : ''
        };
    }

    checkEasternG1Wins() {
        const easternG1Wins = Array.from(this.wonRaces).filter(raceName => {
            const race = this.races.find(r => r.name === raceName);
            return race && this.isGradeOne(race) && this.easternTracks.includes(race.racetrack);
        });
        
        return {
            completed: easternG1Wins.length >= 7,
            current: easternG1Wins.length,
            required: 7,
            progress: (easternG1Wins.length / 7) * 100,
            details: `Eastern G1 wins: ${easternG1Wins.join(', ')}`
        };
    }

    checkWesternG1Wins() {
        const westernG1Wins = Array.from(this.wonRaces).filter(raceName => {
            const race = this.races.find(r => r.name === raceName);
            return race && this.isGradeOne(race) && this.westernTracks.includes(race.racetrack);
        });
        
        return {
            completed: westernG1Wins.length >= 7,
            current: westernG1Wins.length,
            required: 7,
            progress: (westernG1Wins.length / 7) * 100,
            details: `Western G1 wins: ${westernG1Wins.join(', ')}`
        };
    }

    checkDifferentRacecourses() {
        const racecourses = new Set();
        this.selectedRaces.forEach(raceName => {
            const race = this.races.find(r => r.name === raceName);
            if (race) racecourses.add(race.racetrack);
        });
        
        return {
            completed: racecourses.size >= 7,
            current: racecourses.size,
            required: 7,
            progress: (racecourses.size / 7) * 100,
            details: `Racecourses: ${Array.from(racecourses).join(', ')}`
        };
    }

    checkAllDistanceG1() {
        // CSV-aligned: any race win counts (not GI-restricted)
        const distanceWins = { short: false, mile: false, medium: false, long: false };

        Array.from(this.wonRaces).forEach(raceName => {
            const race = this.races.find(r => r.name === raceName);
            if (!race) return;
            Object.keys(distanceWins).forEach(category => {
                if (this.distanceCategories[category](race)) {
                    distanceWins[category] = true;
                }
            });
        });

        const completed = Object.values(distanceWins).every(won => won);
        const current = Object.values(distanceWins).filter(won => won).length;
        
        return {
            completed,
            current,
            required: 4,
            progress: (current / 4) * 100,
            details: `Categories won: ${Object.entries(distanceWins).filter(([k,v]) => v).map(([k,v]) => k).join(', ')}`
        };
    }

    checkNewspaperCups() {
        const newspaperRaces = ['Kyoto Shimbun Hai', 'Kobe Shimbun Hai', 'Chunichi Shimbun Hai', 'Tokyo Shimbun Hai'];
        const wonNewspaperRaces = newspaperRaces.filter(race => this.wonRaces.has(race));
        
        return {
            completed: wonNewspaperRaces.length >= 4,
            current: wonNewspaperRaces.length,
            required: 4,
            progress: (wonNewspaperRaces.length / 4) * 100,
            details: `Won: ${wonNewspaperRaces.join(', ')}`
        };
    }

    checkSummerSeries(seriesKey) {
        const targetList = (this.summerSeries && this.summerSeries[seriesKey]) ? this.summerSeries[seriesKey] : [];
        const wins = targetList.filter(name => this.wonRaces.has(name));
        return {
            completed: wins.length >= 3,
            current: wins.length,
            required: 3,
            progress: Math.min(100, (wins.length / 3) * 100),
            details: `Won: ${wins.join(', ')}`
        };
    }

    checkNewYearGold() {
        // CSV-aligned: Senior year, January, first half; must win Nakayama Kinen or Kyoto Kinen
        const candidates = ['Nakayama Kinen', 'Kyoto Kinen'];
        const qualifyingWins = candidates.filter(raceName => {
            if (!this.wonRaces.has(raceName)) return false;
            const race = this.races.find(r => r.name === raceName);
            return race && race.senior && race.month === 'January' && race.half === '1st';
        });

        return {
            completed: qualifyingWins.length >= 1,
            current: qualifyingWins.length,
            required: 1,
            progress: qualifyingWins.length >= 1 ? 100 : 0,
            details: `Qualified wins: ${qualifyingWins.join(', ')}`
        };
    }

    checkStarRaces() {
        const starRaces = [
            'Procyon Stakes', 'Capella Stakes', 'Centaur Stakes', 'Aldebaran Stakes',
            'Rigel Stakes', 'Betelgeuse Stakes', 'Cassiopeia Stakes', 'Sirius Stakes'
        ];
        const wonStarRaces = starRaces.filter(race => this.wonRaces.has(race));
        
        return {
            completed: wonStarRaces.length >= 3,
            current: wonStarRaces.length,
            required: 3,
            progress: (wonStarRaces.length / 3) * 100,
            details: `Won: ${wonStarRaces.join(', ')}`
        };
    }

    checkJewelryRaces() {
        // Dataset-limited: only a subset available; CSV requires 3 distinct wins
        const jewelryRaces = ['Diamond Stakes', 'Turquoise Stakes', 'Opal Stakes'];
        const wonJewelryRaces = jewelryRaces.filter(race => this.wonRaces.has(race));
        
        return {
            completed: wonJewelryRaces.length >= 3,
            current: wonJewelryRaces.length,
            required: 3,
            progress: Math.min(100, (wonJewelryRaces.length / 3) * 100),
            details: `Won: ${wonJewelryRaces.join(', ')}`
        };
    }

    checkDualSurface() {
        const turfWins = Array.from(this.wonRaces).some(raceName => {
            const race = this.races.find(r => r.name === raceName);
            return race && race.surface === 'turf';
        });
        
        const dirtWins = Array.from(this.wonRaces).some(raceName => {
            const race = this.races.find(r => r.name === raceName);
            return race && race.surface === 'dirt';
        });
        
        const current = (turfWins ? 1 : 0) + (dirtWins ? 1 : 0);
        
        return {
            completed: turfWins && dirtWins,
            current,
            required: 2,
            progress: (current / 2) * 100,
            details: `Surfaces: ${turfWins ? 'Turf' : ''} ${dirtWins ? 'Dirt' : ''}`.trim()
        };
    }

    checkPerfectCrown() {
        const tripleCrownRaces = ['Satsuki Sho', 'Japan Derby', 'Kikka Sho'];
        const groupA = ['Yayoi Sho', 'Spring Stakes', 'Wakaba Stakes']; // Satsuki Sho trials
        const groupB = ['Aoba Sho', 'Principal Stakes']; // Japan Derby trials
        const groupC = ['Kobe Shimbun Hai', 'Saint Lite Kinen']; // Kikka Sho trials

        const wonCrown = tripleCrownRaces.filter(r => this.wonRaces.has(r));
        const groupAHit = groupA.some(r => this.wonRaces.has(r));
        const groupBHit = groupB.some(r => this.wonRaces.has(r));
        const groupCHit = groupC.some(r => this.wonRaces.has(r));

        const crownComplete = wonCrown.length === 3;
        const trialsComplete = groupAHit && groupBHit && groupCHit;
        const completed = crownComplete && trialsComplete;

        const wonTrialsList = [
            ...groupA.filter(r => this.wonRaces.has(r)),
            ...groupB.filter(r => this.wonRaces.has(r)),
            ...groupC.filter(r => this.wonRaces.has(r))
        ];

        return {
            completed,
            current: wonCrown.length + wonTrialsList.length,
            required: 6,
            progress: completed ? 100 : ((wonCrown.length + wonTrialsList.length) / 6) * 100,
            details: `Crown: ${wonCrown.join(', ')} | Trials A:${groupA.filter(r => this.wonRaces.has(r)).join('/')} B:${groupB.filter(r => this.wonRaces.has(r)).join('/')} C:${groupC.filter(r => this.wonRaces.has(r)).join('/')}`
        };
    }

    checkPerfectTiara() {
        const tripleTiaraRaces = ['Oka Sho', 'Oaks', 'Akika Sho'];
        const groupA = ['Fillies Review', 'Tulip Sho', 'Anemone Stakes']; // Oka Sho trials (dataset spelling)
        const groupB = ['Flora Stakes', 'Sweet Pea Stakes']; // Oaks trials
        const groupC = ['Rose Stakes', 'Shion Stakes']; // Akika Sho trials

        const wonTiara = tripleTiaraRaces.filter(r => this.wonRaces.has(r));
        const groupAHit = groupA.some(r => this.wonRaces.has(r));
        const groupBHit = groupB.some(r => this.wonRaces.has(r));
        const groupCHit = groupC.some(r => this.wonRaces.has(r));

        const tiaraComplete = wonTiara.length === 3;
        const trialsComplete = groupAHit && groupBHit && groupCHit;
        const completed = tiaraComplete && trialsComplete;

        const wonTrialsList = [
            ...groupA.filter(r => this.wonRaces.has(r)),
            ...groupB.filter(r => this.wonRaces.has(r)),
            ...groupC.filter(r => this.wonRaces.has(r))
        ];

        return {
            completed,
            current: wonTiara.length + wonTrialsList.length,
            required: 6,
            progress: completed ? 100 : ((wonTiara.length + wonTrialsList.length) / 6) * 100,
            details: `Tiara: ${wonTiara.join(', ')} | Trials A:${groupA.filter(r => this.wonRaces.has(r)).join('/')} B:${groupB.filter(r => this.wonRaces.has(r)).join('/')} C:${groupC.filter(r => this.wonRaces.has(r)).join('/')}`
        };
    }

    checkImprovesWithRacing() {
        // CSV-aligned threshold: 3 consecutive races; we approximate by count ≥ 3
        // Note: true consecutiveness would require calendar order, which is not modeled yet
        const participated = this.selectedRaces.size;

        return {
            completed: participated >= 3,
            current: Math.min(participated, 3),
            required: 3,
            progress: Math.min(100, (participated / 3) * 100),
            details: `Participated in ${participated} races (consecutive check simplified)`
        };
    }

    checkNeverGiveUp() {
        // Simplified: require at least one loss and at least one win (order not enforced)
        const hasLoss = this.lostRaces.size > 0;
        const hasWin = this.wonRaces.size > 0;
        const completed = hasLoss && hasWin;
        return {
            completed,
            current: completed ? 2 : (hasLoss || hasWin ? 1 : 0),
            required: 2,
            progress: completed ? 100 : (hasLoss || hasWin ? 50 : 0),
            details: `Wins: ${this.wonRaces.size}, Losses: ${this.lostRaces.size} (order simplified)`
        };
    }

    checkRebelliousSpirit() {
        // Simplified: assume any win counts as this would require aptitude data
        const wonAny = this.wonRaces.size > 0;
        
        return {
            completed: wonAny,
            current: wonAny ? 1 : 0,
            required: 1,
            progress: wonAny ? 100 : 0,
            details: `Simplified: Any win counts (requires aptitude system)`
        };
    }

    checkDirectionalAwakening(direction) {
        const directionalWins = Array.from(this.wonRaces).filter(raceName => {
            const race = this.races.find(r => r.name === raceName);
            return race && race.direction === direction;
        });
        
        return {
            completed: directionalWins.length >= 6,
            current: directionalWins.length,
            required: 6,
            progress: (directionalWins.length / 6) * 100,
            details: `${direction}-handed wins: ${directionalWins.join(', ')}`
        };
    }

    checkSeasonalAwakening(season) {
        const seasonalWins = Array.from(this.wonRaces).filter(raceName => {
            const race = this.races.find(r => r.name === raceName);
            return race && race.season === season;
        });
        
        return {
            completed: seasonalWins.length >= 6,
            current: seasonalWins.length,
            required: 6,
            progress: (seasonalWins.length / 6) * 100,
            details: `${season} wins: ${seasonalWins.join(', ')}`
        };
    }
}

// Initialize the tracker when the page loads
let tracker;
document.addEventListener('DOMContentLoaded', () => {
    tracker = new UmaMusumeTracker();
});