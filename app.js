// Race data and hidden factors
class UmaMusumeTracker {
    constructor() {
        this.races = [];
        this.hiddenFactors = [];
        this.selectedRaces = new Set();
        this.wonRaces = new Set();
        this.lostRaces = new Set();
        this.currentFilter = 'all';
		// Planner state (game-like UI)
		this.plannerYear = 'junior'; // 'junior' | 'classics' | 'senior'
		this.monthOrder = ['January','February','March','April','May','June','July','August','September','October','November','December'];
		this.halfOrder = ['1st','2nd'];
		this.plannerData = this.createEmptyPlannerData();
        // Modal toggle state
        this.closeOnSelection = true;
        
        this.initializeData();
        this.setupEventListeners();
        this.renderRaces();
		this.renderPlannerGrid();
        this.updateProgress();
        // Sync progress panel height with planner after initial render
        setTimeout(() => this.syncProgressHeightToPlanner(), 0);
    }

    initializeData() {
        // Distance categories (in meters)
        this.distanceCategories = {
            short: race => parseInt(race.length.replace(/[^\d]/g, '')) <= 1400,
            mile: race => {
                const length = parseInt(race.length.replace(/[^\d]/g, ''));
                return length >= 1500 && length <= 1700;
            },
            medium: race => {
                const length = parseInt(race.length.replace(/[^\d]/g, ''));
                return length >= 1800 && length <= 2200;
            },
            long: race => parseInt(race.length.replace(/[^\d]/g, '')) >= 2300
        };

        // Eastern Japan tracks
        this.easternTracks = ['Tokyo', 'Nakayama (Chiba)', 'Niigata', 'Fukushima', 'Kawasaki', 'Ooi', 'Funabashi', 'Morioka'];
        
        // Western Japan tracks  
        this.westernTracks = ['Kyoto', 'Hanshin (Takarazuka)', 'Chukyou (Nagoya)', 'Kokura (Kitakyushu)', 'Sapporo', 'Hakodate'];

        // JRA Summer Series groupings (dataset-aligned names)
        this.summerSeries = {
            sprint: [
                'Hakodate Sprint Stakes',
                'CBC Sho',
                'Ibis Summer Dash',
                'Keeneland Cup',
                'Kitakyushu Kinen',
                'Centaur Stakes'
            ],
            mile: [
                // Official series includes Epsom Cup (1800m) alongside mile-targeted handicaps
                'Epsom Cup',
                'Chukyo Kinen',
                'Sekiya Kinen'
            ],
            s2000: [
                'Hakodate Kinen',
                'Tanabata Sho',
                'Kokura Kinen',
                'Sapporo Kinen',
                'Niigata Kinen'
            ]
        };

        // Translation maps
        this.translations = {
            tracks: {
                'Tokyo': 'æ±äº¬',
                'Nakayama (Chiba)': 'ä¸­å±±',
                'Kyoto': 'äº¬éƒ½',
                'Hanshin (Takarazuka)': 'é˜ªç¥',
                'Chukyou (Nagoya)': 'ä¸­äº¬',
                'Kokura (Kitakyushu)': 'å°å€‰',
                'Sapporo': 'æœ­å¹Œ',
                'Hakodate': 'å‡½é¤¨',
                'Niigata': 'æ–°æ½Ÿ',
                'Fukushima': 'ç¦å³¶',
                'Kawasaki': 'å·å´',
                'Ooi': 'å¤§äº•',
                'Funabashi': 'èˆ¹æ©‹',
                'Morioka': 'ç››å²¡'
            },
            surfaces: {
                'turf': 'èŠ',
                'dirt': 'ãƒ€ãƒ¼ãƒˆ'
            },
            months: {
                'January': '1æœˆ',
                'February': '2æœˆ',
                'March': '3æœˆ',
                'April': '4æœˆ',
                'May': '5æœˆ',
                'June': '6æœˆ',
                'July': '7æœˆ',
                'August': '8æœˆ',
                'September': '9æœˆ',
                'October': '10æœˆ',
                'November': '11æœˆ',
                'December': '12æœˆ'
            },
            halves: {
                '1st': 'å‰åŠ',
                '2nd': 'å¾ŒåŠ'
            },
            directions: {
                'right': 'å³å›ã‚Š',
                'left': 'å·¦å›ã‚Š'
            },
            seasons: {
                'spring': 'æ˜¥',
                'summer': 'å¤',
                'autumn': 'ç§‹',
                'winter': 'å†¬'
            },
            types: {
                'Classic': 'ã‚¯ãƒ©ã‚·ãƒƒã‚¯ç´š',
                'Senior': 'ã‚·ãƒ‹ã‚¢ç´š', 
                'Junior': 'ã‚¸ãƒ¥ãƒ‹ã‚¢ç´š'
            }
        };

        // Load race data
        this.loadRaceData();
        
        // Load hidden factors
        this.loadHiddenFactors();
    }

    loadRaceData() {
        // Prefer prebuilt dataset if available (generated by generate_races_js.py)
        if (typeof window !== 'undefined' && window.RACES && Array.isArray(window.RACES)) {
            this.races = window.RACES;
            // Update data source indicator
            const ind = document.getElementById('data-source-indicator');
            if (ind) {
                const meta = (typeof window !== 'undefined' && window.RACES_META) ? window.RACES_META : null;
                const dateText = meta && meta.generatedAt ? new Date(meta.generatedAt).toLocaleString() : 'unknown time';
                const countText = meta && meta.count != null ? ` (${meta.count} races)` : '';
                ind.textContent = `Data source: races.js â€” generated ${dateText}${countText}`;
            }
            this.buildRaceMaps();
            return;
        }
        // Fallback: parse embedded sample CSV
        this.races = this.parseCSVData();
        this.buildRaceMaps();
        const ind = document.getElementById('data-source-indicator');
        if (ind) {
            ind.textContent = 'Data source: embedded fallback dataset (sample)';
        }
    }

    buildRaceMaps() {
        this.raceById = new Map(this.races.map(r => [String(r.id), r]));
        // Build a mapping from English race name -> Set of IDs (handles duplicates across years)
        this.raceIdsByName = new Map();
        this.races.forEach(race => {
            const id = String(race.id);
            const name = race.name || '';
            if (!name) return;
            if (!this.raceIdsByName.has(name)) this.raceIdsByName.set(name, new Set());
            this.raceIdsByName.get(name).add(id);
        });
    }

    parseCSVData() {
        // CSV data from RaceComplete.csv - representative sample
        const csvData = `å‡½é¤¨ã‚¸ãƒ¥ãƒ‹ã‚¢ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Hakodate Junior Stakes,6æœˆå¾ŒåŠ,1å¹´ç›®,ã‚¸ãƒ¥ãƒ‹ã‚¢,,,G3,å‡½é¤¨,èŠ,1200m,çŸ­è·é›¢,å³,,,
ä¸­äº¬ã‚¸ãƒ¥ãƒ‹ã‚¢ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Chukyo Junior Stakes,7æœˆå¾ŒåŠ,1å¹´ç›®,ã‚¸ãƒ¥ãƒ‹ã‚¢,,,OP,ä¸­äº¬,èŠ,1600m,ãƒã‚¤ãƒ«,å·¦,,,
æœæ—¥æ¯ãƒ•ãƒ¥ãƒ¼ãƒãƒ¥ãƒªãƒ†ã‚£ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Asahi Hai Futurity Stakes,12æœˆå‰åŠ,1å¹´ç›®,ã‚¸ãƒ¥ãƒ‹ã‚¢,,,G1,é˜ªç¥,èŠ,1600m,ãƒã‚¤ãƒ«,å³,å¤–,,
é˜ªç¥ã‚¸ãƒ¥ãƒ™ãƒŠã‚¤ãƒ«ãƒ•ã‚£ãƒªãƒ¼ã‚º,Hanshin Juvenile Fillies,12æœˆå‰åŠ,1å¹´ç›®,ã‚¸ãƒ¥ãƒ‹ã‚¢,,,G1,é˜ªç¥,èŠ,1600m,ãƒã‚¤ãƒ«,å³,å¤–,,
ãƒ›ãƒ¼ãƒ—ãƒ•ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Hopeful Stakes,12æœˆå¾ŒåŠ,1å¹´ç›®,ã‚¸ãƒ¥ãƒ‹ã‚¢,,,G1,ä¸­å±±,èŠ,2000m,ä¸­è·é›¢,å³,å†…,,
äº¬æˆæ¯,Keisei Hai,1æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G3,ä¸­å±±,èŠ,2000m,ä¸­è·é›¢,å³,å†…,,
ãƒ•ã‚§ã‚¢ãƒªãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Fairy Stakes,1æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G3,ä¸­å±±,èŠ,1600m,ãƒã‚¤ãƒ«,å³,å¤–,,
ã‚·ãƒ³ã‚¶ãƒ³è¨˜å¿µ,Shinzan Kinen,1æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G3,äº¬éƒ½,èŠ,1600m,ãƒã‚¤ãƒ«,å³,å¤–,,
çšæœˆè³,Satsuki Sho,4æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G1,ä¸­å±±,èŠ,2000m,ä¸­è·é›¢,å³,å†…,,
æ¡œèŠ±è³,Oka Sho,4æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G1,é˜ªç¥,èŠ,1600m,ãƒã‚¤ãƒ«,å³,å¤–,,
NHKãƒã‚¤ãƒ«ã‚«ãƒƒãƒ—,NHK Mile Cup,5æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G1,æ±äº¬,èŠ,1600m,ãƒã‚¤ãƒ«,å·¦,,,
æ—¥æœ¬ãƒ€ãƒ¼ãƒ“ãƒ¼,Japan Derby,5æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G1,æ±äº¬,èŠ,2400m,ä¸­è·é›¢,å·¦,,,
ã‚ªãƒ¼ã‚¯ã‚¹,Oaks,5æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G1,æ±äº¬,èŠ,2400m,ä¸­è·é›¢,å·¦,,,
å®‰ç”°è¨˜å¿µ,Yasuda Kinen,6æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,ã‚·ãƒ‹ã‚¢,G1,æ±äº¬,èŠ,1600m,ãƒã‚¤ãƒ«,å·¦,,,
å®å¡šè¨˜å¿µ,Takarazuka Kinen,6æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,ã‚·ãƒ‹ã‚¢,G1,é˜ªç¥,èŠ,2200m,ä¸­è·é›¢,å³,å†…,,
ã‚¹ãƒ—ãƒªãƒ³ã‚¿ãƒ¼ã‚ºã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Sprinters Stakes,9æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,ã‚·ãƒ‹ã‚¢,G1,ä¸­å±±,èŠ,1200m,çŸ­è·é›¢,å³,å¤–,,
ç¥æˆ¸æ–°èæ¯,Kobe Shimbun Hai,9æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G2,é˜ªç¥,èŠ,2400m,ä¸­è·é›¢,å³,å¤–,,
èŠèŠ±è³,Kikka Sho,10æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G1,äº¬éƒ½,èŠ,3000m,é•·è·é›¢,å³,å¤–,,
ç§‹è¯è³,Akika Sho,10æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G1,äº¬éƒ½,èŠ,2000m,ä¸­è·é›¢,å³,å†…,,
å¤©çš‡è³ï¼ˆç§‹ï¼‰,Tenno Sho (Autumn),10æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,ã‚·ãƒ‹ã‚¢,G1,æ±äº¬,èŠ,2000m,ä¸­è·é›¢,å·¦,,,
ã‚¨ãƒªã‚¶ãƒ™ã‚¹å¥³ç‹æ¯,Queen Elizabeth II Cup,11æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,ã‚·ãƒ‹ã‚¢,G1,äº¬éƒ½,èŠ,2200m,ä¸­è·é›¢,å³,å¤–,,
ã‚¸ãƒ£ãƒ‘ãƒ³ã‚«ãƒƒãƒ—,Japan Cup,11æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,ã‚·ãƒ‹ã‚¢,G1,æ±äº¬,èŠ,2400m,ä¸­è·é›¢,å·¦,,,
ãƒã‚¤ãƒ«ãƒãƒ£ãƒ³ãƒ”ã‚ªãƒ³ã‚·ãƒƒãƒ—,Mile Championship,11æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,ã‚·ãƒ‹ã‚¢,G1,äº¬éƒ½,èŠ,1600m,ãƒã‚¤ãƒ«,å³,å¤–,,
ãƒãƒ£ãƒ³ãƒ”ã‚ªãƒ³ã‚ºã‚«ãƒƒãƒ—,Champions Cup,12æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,ã‚·ãƒ‹ã‚¢,G1,ä¸­äº¬,ãƒ€ãƒ¼ãƒˆ,1800m,ãƒã‚¤ãƒ«,å·¦,,,
æœ‰é¦¬è¨˜å¿µ,Arima Kinen,12æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,ã‚·ãƒ‹ã‚¢,G1,ä¸­å±±,èŠ,2500m,é•·è·é›¢,å³,å†…,,
äº¬éƒ½é‡‘æ¯,Kyoto Kinen,1æœˆå‰åŠ,3å¹´ç›®,,,ã‚·ãƒ‹ã‚¢,G3,äº¬éƒ½,èŠ,1600m,ãƒã‚¤ãƒ«,å³,å¤–,,
ä¸­å±±é‡‘æ¯,Nakayama Kinen,1æœˆå‰åŠ,3å¹´ç›®,,,ã‚·ãƒ‹ã‚¢,G3,ä¸­å±±,èŠ,2000m,ä¸­è·é›¢,å³,å†…,,
æ±äº¬æ–°èæ¯,Tokyo Shimbun Hai,2æœˆå‰åŠ,3å¹´ç›®,,,ã‚·ãƒ‹ã‚¢,G3,æ±äº¬,èŠ,1600m,ãƒã‚¤ãƒ«,å·¦,,,
ãƒ•ã‚§ãƒ–ãƒ©ãƒªãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,February Stakes,2æœˆå¾ŒåŠ,3å¹´ç›®,,,ã‚·ãƒ‹ã‚¢,G1,æ±äº¬,ãƒ€ãƒ¼ãƒˆ,1600m,ãƒã‚¤ãƒ«,å·¦,,,
é«˜æ¾å®®è¨˜å¿µ,Takamatsunomiya Kinen,3æœˆå¾ŒåŠ,3å¹´ç›®,,,ã‚·ãƒ‹ã‚¢,G1,ä¸­äº¬,èŠ,1200m,çŸ­è·é›¢,å·¦,,,
å¤§é˜ªæ¯,Osaka Hai,3æœˆå¾ŒåŠ,3å¹´ç›®,,,ã‚·ãƒ‹ã‚¢,G1,é˜ªç¥,èŠ,2000m,ä¸­è·é›¢,å³,å†…,,
å¤©çš‡è³ï¼ˆæ˜¥ï¼‰,Tenno Sho (Spring),4æœˆå¾ŒåŠ,3å¹´ç›®,,,ã‚·ãƒ‹ã‚¢,G1,äº¬éƒ½,èŠ,3200m,é•·è·é›¢,å³,å¤–,,
ãƒ´ã‚£ã‚¯ãƒˆãƒªã‚¢ãƒã‚¤ãƒ«,Victoria Mile,5æœˆå‰åŠ,3å¹´ç›®,,,ã‚·ãƒ‹ã‚¢,G1,æ±äº¬,èŠ,1600m,ãƒã‚¤ãƒ«,å·¦,,,
å¸ç‹è³,Teioh Sho,6æœˆå¾ŒåŠ,3å¹´ç›®,,,ã‚·ãƒ‹ã‚¢,G1,å¤§äº•,ãƒ€ãƒ¼ãƒˆ,2000m,ä¸­è·é›¢,å³,,,
ãƒ—ãƒ­ã‚­ã‚ªãƒ³ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Procyon Stakes,7æœˆå‰åŠ,3å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,ã‚·ãƒ‹ã‚¢,G3,ä¸­äº¬,ãƒ€ãƒ¼ãƒˆ,1400m,çŸ­è·é›¢,å·¦,,,
ã‚«ãƒšãƒ©ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Capella Stakes,12æœˆå‰åŠ,3å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,ã‚·ãƒ‹ã‚¢,G3,ä¸­å±±,ãƒ€ãƒ¼ãƒˆ,1200m,çŸ­è·é›¢,å³,,,
ã‚»ãƒ³ãƒˆã‚¦ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Centaur Stakes,9æœˆå‰åŠ,3å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,ã‚·ãƒ‹ã‚¢,G2,é˜ªç¥,èŠ,1200m,çŸ­è·é›¢,å³,å†…,,
ãƒ€ã‚¤ãƒ¤ãƒ¢ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Diamond Stakes,2æœˆå¾ŒåŠ,3å¹´ç›®,,,ã‚·ãƒ‹ã‚¢,G3,æ±äº¬,èŠ,3400m,é•·è·é›¢,å·¦,,,
ã‚¿ãƒ¼ã‚³ã‚¤ã‚ºã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Turquoise Stakes,12æœˆå‰åŠ,3å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,ã‚·ãƒ‹ã‚¢,G3,ä¸­å±±,èŠ,1600m,ãƒã‚¤ãƒ«,å³,å¤–,,
ã‚·ãƒ«ã‚¯ãƒ­ãƒ¼ãƒ‰ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Silk Road Stakes,1æœˆå¾ŒåŠ,3å¹´ç›®,,,ã‚·ãƒ‹ã‚¢,G3,äº¬éƒ½,èŠ,1200m,çŸ­è·é›¢,å³,å†…,,
ã‚ªãƒ¼ã‚·ãƒ£ãƒ³ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Ocean Stakes,3æœˆå‰åŠ,3å¹´ç›®,,,ã‚·ãƒ‹ã‚¢,G3,ä¸­å±±,èŠ,1200m,çŸ­è·é›¢,å³,å¤–,,
ã‚¢ãƒ«ãƒ‡ãƒãƒ©ãƒ³ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Aldebaran Stakes,2æœˆå‰åŠ,3å¹´ç›®,,,ã‚·ãƒ‹ã‚¢,OP,äº¬éƒ½,ãƒ€ãƒ¼ãƒˆ,1900m,ä¸­è·é›¢,å³,,,
ãƒªã‚²ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Rigel Stakes,12æœˆå‰åŠ,3å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,ã‚·ãƒ‹ã‚¢,OP,é˜ªç¥,èŠ,1600m,ãƒã‚¤ãƒ«,å³,å¤–,,
ãƒ™ãƒ†ãƒ«ã‚®ã‚¦ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Betelgeuse Stakes,12æœˆå¾ŒåŠ,3å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,ã‚·ãƒ‹ã‚¢,OP,é˜ªç¥,ãƒ€ãƒ¼ãƒˆ,1800m,ãƒã‚¤ãƒ«,å³,,,
äº¬éƒ½æ–°èæ¯,Kyoto Shimbun Hai,5æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G2,äº¬éƒ½,èŠ,2200m,ä¸­è·é›¢,å³,å¤–,,
ä¸­æ—¥æ–°èæ¯,Chunichi Shimbun Hai,12æœˆå‰åŠ,3å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,ã‚·ãƒ‹ã‚¢,G3,ä¸­äº¬,èŠ,2000m,ä¸­è·é›¢,å·¦,,,
å¼¥ç”Ÿè³,Yayoi Sho,3æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G2,ä¸­å±±,èŠ,2000m,ä¸­è·é›¢,å³,å†…,,
ã‚¹ãƒ—ãƒªãƒ³ã‚°ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Spring Stakes,3æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G2,ä¸­å±±,èŠ,1800m,ãƒã‚¤ãƒ«,å³,å†…,,
ã‚»ãƒ³ãƒˆãƒ©ã‚¤ãƒˆè¨˜å¿µ,Saint Lite Kinen,9æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G2,ä¸­å±±,èŠ,2200m,ä¸­è·é›¢,å³,å¤–,,
ãƒãƒ¥ãƒ¼ãƒªãƒƒãƒ—è³,Tulip Sho,3æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G2,é˜ªç¥,èŠ,1600m,ãƒã‚¤ãƒ«,å³,å¤–,,
ãƒ•ãƒ­ãƒ¼ãƒ©ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Flora Stakes,4æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G2,æ±äº¬,èŠ,2000m,ä¸­è·é›¢,å·¦,,,
ãƒ­ãƒ¼ã‚ºã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Rose Stakes,9æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G2,é˜ªç¥,èŠ,1800m,ãƒã‚¤ãƒ«,å³,å¤–,,
ã‚¢ãƒãƒ¢ãƒã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Anemone Stakes,3æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,OP,ä¸­å±±,èŠ,1600m,ãƒã‚¤ãƒ«,å³,å¤–,,,
ãƒ•ã‚£ãƒªãƒ¼ã‚ºãƒ¬ãƒ“ãƒ¥ãƒ¼,Fillies Review,3æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G2,é˜ªç¥,èŠ,1400m,çŸ­è·é›¢,å³,å†…,,,
è‹¥è‘‰ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Wakaba Stakes,3æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,OP,é˜ªç¥,èŠ,2000m,ä¸­è·é›¢,å³,å†…,,,
é’è‘‰è³,Aoba Sho,4æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G2,æ±äº¬,èŠ,2400m,ä¸­è·é›¢,å·¦,,,
ã‚¹ã‚¤ãƒ¼ãƒˆãƒ”ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Sweet Pea Stakes,4æœˆå¾ŒåŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,OP,æ±äº¬,èŠ,1800m,ãƒã‚¤ãƒ«,å·¦,,,
ãƒ—ãƒªãƒ³ã‚·ãƒ‘ãƒ«ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Principal Stakes,5æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,OP,æ±äº¬,èŠ,2000m,ä¸­è·é›¢,å·¦,,,
ç´«è‹‘ã‚¹ãƒ†ãƒ¼ã‚¯ã‚¹,Shion Stakes,9æœˆå‰åŠ,2å¹´ç›®,,ã‚¯ãƒ©ã‚·ãƒƒã‚¯,,G3,ä¸­å±±,èŠ,2000m,ä¸­è·é›¢,å³,å†…,,`;

        const lines = csvData.trim().split('\n');
        const races = [];
        
        // Parse each line of CSV data
        for (let i = 0; i < lines.length; i++) {
            const values = this.parseCSVLine(lines[i]);
            if (values.length >= 13) {
                const race = this.createRaceObject(values);
                if (race) {
                    races.push(race);
                }
            }
        }
        
        return races;
    }

    // Normalize grade-one detection across possible encodings (GI, G1)
    isGradeOne(race) {
        if (!race || !race.type) return false;
        const t = String(race.type).toUpperCase().replace(/\s+/g, '');
        return t === 'GI' || t === 'G1';
    }

    parseCSVLine(line) {
        return line.split(',');
    }

    createRaceObject(values) {
	        const [nameJP, nameEN, date, year, junior, classics, senior, grade, location, ground, distance, distanceCategory, direction, innerOuter, imageField, imageLink] = values;
        
        // Use English name if available, otherwise use Japanese name
        const name = nameEN.trim() || nameJP.trim();
        
        // Parse month and half from date (e.g., "6æœˆå¾ŒåŠ" -> month: "June", half: "2nd")
        const monthHalf = this.parseDateString(date);
        
        // Convert grade format
        const type = this.convertGrade(grade);
        
        // Convert surface
        const surface = this.convertSurface(ground);
        
        // Convert track name
        const racetrack = this.convertTrackName(location);
        
        // Convert direction
        const convertedDirection = this.convertDirection(direction);
        
        // Determine season from month
        const season = this.getSeason(monthHalf.month);
        
        // Image fields (local + remote). Prefer CSV-provided link; else enrich via known mapping.
        let imageRemote = (imageLink || '').trim();
        let image = (imageField || '').trim();
        
        // If remote is present, derive local path from its filename
        if (imageRemote && !image) {
            const filename = imageRemote.split('/').pop();
            if (filename) image = `race_images/${filename}`;
        } else if (image && !image.startsWith('race_images/')) {
            // If CSV included a bare filename, prefix with local folder
            image = `race_images/${image}`;
        }
        
	        // Enrich missing remote images using a small built-in mapping for the fallback sample
        if (!imageRemote) {
            const imageRemoteByName = {
                'Hakodate Junior Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race2.png',
                'Chukyo Junior Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race1.png',
                'Asahi Hai Futurity Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race52.png',
                'Hanshin Juvenile Fillies': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race51.png',
                'Hopeful Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race55.png',
                'Keisei Hai': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race60.png',
                'Fairy Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race56.png',
                'Shinzan Kinen': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race59.png',
                'Satsuki Sho': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race83.png',
                'Oka Sho': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race82.png',
                'NHK Mile Cup': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race93.png',
                'Japan Derby': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race98.png',
                'Oaks': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race97.png',
                'Yasuda Kinen': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race102.png',
                'Takarazuka Kinen': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race112.png',
                'Sprinters Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race156.png',
                'Kobe Shimbun Hai': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race150.png',
                'Kikka Sho': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race173.png',
                'Tenno Sho (Autumn)': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race171.png',
                'Queen Elizabeth II Cup': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race179.png',
                'Japan Cup': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race190.png',
                'Mile Championship': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race189.png',
                'Champions Cup': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race201.png',
                'Arima Kinen': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race205.png',
                'Tokyo Shimbun Hai': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race224.png',
                'February Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race236.png',
                'Takamatsunomiya Kinen': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race249.png',
                'Osaka Hai': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race250.png',
                'Tenno Sho (Spring)': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race263.png',
                'Victoria Mile': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race272.png',
                'Teioh Sho': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race285.png',
                'Procyon Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race115.png',
                'Capella Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race194.png',
                'Centaur Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race142.png',
                'Diamond Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race231.png',
                'Turquoise Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race195.png',
                'Silk Road Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race219.png',
                'Ocean Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race238.png',
                'Aldebaran Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race227.png',
                'Rigel Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race198.png',
                'Betelgeuse Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race204.png',
                'Kyoto Shimbun Hai': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race94.png',
                'Chunichi Shimbun Hai': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race193.png',
                'Yayoi Sho': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race72.png',
                'Spring Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race77.png',
                'Tulip Sho': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race74.png',
                'Flora Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race89.png',
                'Rose Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race143.png',
                'Akika Sho': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race172.png',
                'Saint Lite Kinen': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race152.png',
                'Anemone Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race70.png',
                'Fillies Review': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race73.png',
                'Wakaba Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race76.png',
                'Aoba Sho': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race90.png',
                'Sweet Pea Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race88.png',
                'Principal Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race91.png',
                'Shion Stakes': 'https://img.gamewith.jp/article_tools/uma-musume/gacha/i_race146.png'
            };
            imageRemote = imageRemoteByName[name] || '';
            if (imageRemote && !image) {
                const filename = imageRemote.split('/').pop();
                if (filename) image = `race_images/${filename}`;
            }
        }
	        
	        // Derive year flags exclusively from Year (fallback to explicit columns if Year missing)
	        const yearStr = (year || '').trim();
	        let juniorFlag = false, classicsFlag = false, seniorFlag = false;
	        const yMatch = yearStr.match(/(\d)å¹´ç›®/);
	        if (yMatch) {
	            const y = parseInt(yMatch[1], 10);
	            if (y === 1) juniorFlag = true;
	            else if (y === 2) classicsFlag = true;
	            else if (y === 3) seniorFlag = true;
	        } else {
	            juniorFlag = (junior || '').trim() === 'ã‚¸ãƒ¥ãƒ‹ã‚¢';
	            classicsFlag = (classics || '').trim() === 'ã‚¯ãƒ©ã‚·ãƒƒã‚¯';
	            seniorFlag = (senior || '').trim() === 'ã‚·ãƒ‹ã‚¢';
	        }
	        
	        return {
            name: name,
            nameJP: nameJP.trim(),
            type: type,
            length: distance,
            surface: surface,
            racetrack: racetrack,
	            junior: juniorFlag,
	            classics: classicsFlag,
	            senior: seniorFlag,
            month: monthHalf.month,
            half: monthHalf.half,
            direction: convertedDirection,
            season: season,
            ...(image ? { image } : {}),
            ...(imageRemote ? { imageRemote } : {})
        };
    }

    parseDateString(dateStr) {
        const monthMap = {
            '1æœˆ': 'January', '2æœˆ': 'February', '3æœˆ': 'March', '4æœˆ': 'April',
            '5æœˆ': 'May', '6æœˆ': 'June', '7æœˆ': 'July', '8æœˆ': 'August',
            '9æœˆ': 'September', '10æœˆ': 'October', '11æœˆ': 'November', '12æœˆ': 'December'
        };
        
        const halfMap = {
            'å‰åŠ': '1st',
            'å¾ŒåŠ': '2nd'
        };
        
        // Extract month and half from strings like "6æœˆå¾ŒåŠ"
        const monthMatch = dateStr.match(/(\d+æœˆ)/);
        const halfMatch = dateStr.match(/(å‰åŠ|å¾ŒåŠ)/);
        
        const month = monthMatch ? monthMap[monthMatch[1]] || 'January' : 'January';
        const half = halfMatch ? halfMap[halfMatch[1]] || '1st' : '1st';
        
        return { month, half };
    }

    convertGrade(grade) {
        const gradeMap = {
            'G1': 'GI',
            'G2': 'GII',
            'G3': 'GIII',
            'OP': 'Open',
            'Pre-OP': 'Pre-OP'
        };
        return gradeMap[grade] || grade;
    }

    convertSurface(ground) {
        const surfaceMap = {
            'èŠ': 'turf',
            'ãƒ€ãƒ¼ãƒˆ': 'dirt'
        };
        return surfaceMap[ground] || ground;
    }

    convertTrackName(location) {
        const trackMap = {
            'æ±äº¬': 'Tokyo',
            'ä¸­å±±': 'Nakayama (Chiba)',
            'äº¬éƒ½': 'Kyoto',
            'é˜ªç¥': 'Hanshin (Takarazuka)',
            'ä¸­äº¬': 'Chukyou (Nagoya)',
            'å°å€‰': 'Kokura (Kitakyushu)',
            'æœ­å¹Œ': 'Sapporo',
            'å‡½é¤¨': 'Hakodate',
            'æ–°æ½Ÿ': 'Niigata',
            'ç¦å³¶': 'Fukushima',
            'å·å´': 'Kawasaki',
            'å¤§äº•': 'Ooi',
            'èˆ¹æ©‹': 'Funabashi',
            'ç››å²¡': 'Morioka'
        };
        return trackMap[location] || location;
    }

    convertDirection(direction) {
        const directionMap = {
            'å³': 'right',
            'å·¦': 'left',
            'ç›´ç·š': 'straight'
        };
        return directionMap[direction] || direction;
    }

    getSeason(month) {
        const seasonMap = {
            'December': 'winter', 'January': 'winter', 'February': 'winter',
            'March': 'spring', 'April': 'spring', 'May': 'spring',
            'June': 'summer', 'July': 'summer', 'August': 'summer',
            'September': 'autumn', 'October': 'autumn', 'November': 'autumn'
        };
        return seasonMap[month] || 'spring';
    }

    loadHiddenFactors() {
        this.hiddenFactors = [
            {
                id: 'consecutive_run',
                nameJP: 'é€£æˆ¦é€£å‹',
                nameEN: 'Consecutive Runs',
                conditionJP: '2æˆ¦é€£ç¶šã§å‡ºèµ°ã™ã‚‹ã€‚',
                conditionEN: 'Race 2 races in a row.',
                check: () => this.checkConsecutiveRuns()
            },
            {
                id: 'champion_east',
                nameJP: 'æ±ã®é›„',
                nameEN: 'Champion of the East',
                conditionJP: 'æ±æ—¥æœ¬ï¼ˆæ±äº¬ã€ä¸­å±±ãªã©ï¼‰ã®G1ãƒ¬ãƒ¼ã‚¹ã§7å‹ä»¥ä¸Šã™ã‚‹ã€‚',
                conditionEN: 'Win 7 or more G1 races held at tracks in eastern Japan (e.g., Tokyo, Nakayama).',
                check: () => this.checkEasternG1Wins()
            },
            {
                id: 'champion_west',
                nameJP: 'è¥¿ã®é›„',
                nameEN: 'Champion of the West',
                conditionJP: 'è¥¿æ—¥æœ¬ï¼ˆäº¬éƒ½ã€é˜ªç¥ãªã©ï¼‰ã®G1ãƒ¬ãƒ¼ã‚¹ã§7å‹ä»¥ä¸Šã™ã‚‹ã€‚',
                conditionEN: 'Win 7 or more G1 races held at tracks in western Japan (e.g., Kyoto, Hanshin).',
                check: () => this.checkWesternG1Wins()
            },
            {
                id: 'traveler',
                nameJP: 'æ—…äºº',
                nameEN: 'Traveler',
                conditionJP: '7ç¨®é¡ä»¥ä¸Šã®ãƒ¬ãƒ¼ã‚¹å ´ã«å‡ºèµ°ã™ã‚‹ï¼ˆå‹åˆ©ã¯ä¸å•ï¼‰ã€‚',
                conditionEN: 'Compete at 7 or more different racecourses. Winning is not a requirement.',
                check: () => this.checkDifferentRacecourses()
            },
            {
                id: 'all_ranks_conquered',
                nameJP: 'å…¨éšç´šåˆ¶è¦‡',
                nameEN: 'All Ranks Conquered',
                conditionJP: 'çŸ­è·é›¢ã€ãƒã‚¤ãƒ«ã€ä¸­è·é›¢ã€é•·è·é›¢ã®å„è·é›¢ã§1å›ä»¥ä¸Šå‹åˆ©ã™ã‚‹ã€‚',
                conditionEN: 'Win at least one race in each distance category: Short, Mile, Medium, and Long.',
                check: () => this.checkAllDistanceG1()
            },
            {
                id: 'newspaper_boy',
                nameJP: 'æ–°èå±‹ã•ã‚“',
                nameEN: 'Newspaper Boy/Girl',
                conditionJP: 'æŒ‡å®šã•ã‚ŒãŸ4ã¤ã®ã€Œæ–°èæ¯ã€ãƒ¬ãƒ¼ã‚¹ï¼ˆäº¬éƒ½æ–°èæ¯ã€ç¥æˆ¸æ–°èæ¯ã€ä¸­æ—¥æ–°èæ¯ã€æ±äº¬æ–°èæ¯ï¼‰ã«å‹åˆ©ã™ã‚‹ã€‚',
                conditionEN: 'Win the four "Shimbun Hai" races: Kyoto, Kobe, Chunichi, and Tokyo Shimbun Hai.',
                check: () => this.checkNewspaperCups()
            },
            {
                id: 'summer_sprint_series',
                nameJP: 'SSS',
                nameEN: 'Summer Sprint Series',
                conditionJP: 'ã‚µãƒãƒ¼ã‚¹ãƒ—ãƒªãƒ³ãƒˆã‚·ãƒªãƒ¼ã‚ºå¯¾è±¡ãƒ¬ãƒ¼ã‚¹ã‹ã‚‰3å‹ã™ã‚‹ã€‚',
                conditionEN: 'Win 3 races from the Summer Sprint Series.',
                check: () => this.checkSummerSeries('sprint')
            },
            {
                id: 'summer_mile_series',
                nameJP: 'SMS',
                nameEN: 'Summer Mile Series',
                conditionJP: 'ã‚µãƒãƒ¼ãƒã‚¤ãƒ«ã‚·ãƒªãƒ¼ã‚ºå¯¾è±¡ãƒ¬ãƒ¼ã‚¹ã‹ã‚‰3å‹ã™ã‚‹ã€‚',
                conditionEN: 'Win 3 races from the Summer Mile Series.',
                check: () => this.checkSummerSeries('mile')
            },
            {
                id: 'summer_2000_series',
                nameJP: 'S2000',
                nameEN: 'Summer 2000 Series',
                conditionJP: 'ã‚µãƒãƒ¼2000ã‚·ãƒªãƒ¼ã‚ºå¯¾è±¡ãƒ¬ãƒ¼ã‚¹ã‹ã‚‰3å‹ã™ã‚‹ã€‚',
                conditionEN: 'Win 3 races from the Summer 2000 Series.',
                check: () => this.checkSummerSeries('s2000')
            },
            {
                id: 'years_plan',
                nameJP: 'ä¸€å¹´ã®è¨ˆã¯',
                nameEN: "The Year's Plan",
                conditionJP: 'ã‚·ãƒ‹ã‚¢ç´š1æœˆå‰åŠã®ä¸­å±±é‡‘æ¯ã‹äº¬éƒ½é‡‘æ¯ã§å‹åˆ©ã™ã‚‹ã€‚',
                conditionEN: 'During the Senior year, win either the Nakayama Kinen or the Kyoto Kinen in January.',
                check: () => this.checkNewYearGold()
            },
            {
                id: 'wish_upon_star',
                nameJP: 'æ˜Ÿã«é¡˜ã„ã‚’',
                nameEN: 'Wish Upon a Star',
                conditionJP: 'æŒ‡å®šã•ã‚ŒãŸæ˜Ÿãƒ»æ˜Ÿåº§é–¢é€£ã®åå‰ã‚’æŒã¤ãƒ¬ãƒ¼ã‚¹ã®ä¸­ã‹ã‚‰3å‹ä»¥ä¸Šã™ã‚‹ã€‚',
                conditionEN: 'Win 3 or more races from the designated list of star or constellation-themed races.',
                check: () => this.checkStarRaces()
            },
            {
                id: 'jewelry',
                nameJP: 'ã‚¸ãƒ¥ã‚¨ãƒªãƒ¼',
                nameEN: 'Jewelry',
                conditionJP: 'æŒ‡å®šã•ã‚ŒãŸå®çŸ³ã®åå‰ã‚’æŒã¤ãƒ¬ãƒ¼ã‚¹ã®ä¸­ã‹ã‚‰3å‹ä»¥ä¸Šã™ã‚‹ï¼ˆåŒåãƒ¬ãƒ¼ã‚¹ã®é‡è¤‡ã¯ä¸å¯ï¼‰ã€‚',
                conditionEN: 'Win 3 or more races from the designated list of jewelry-themed races.',
                check: () => this.checkJewelryRaces()
            },
            {
                id: 'dual_wielder',
                nameJP: 'äºŒåˆ€æµ',
                nameEN: 'Two-Sword Style / Dual Wielder',
                conditionJP: 'èŠã¨ãƒ€ãƒ¼ãƒˆã®ä¸¡æ–¹ã®ãƒå ´é©æ€§ã‚’Aã«ã™ã‚‹ã€‚',
                conditionEN: "Achieve an 'A' rank aptitude for both Turf and Dirt surfaces.",
                check: () => this.checkDualSurface()
            },
            {
                id: 'perfect_crown',
                nameJP: 'ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¦ãƒ³',
                nameEN: 'Perfect Crown',
                conditionJP: 'ç‰¡é¦¬ä¸‰å† ãƒ¬ãƒ¼ã‚¹ï¼ˆçšæœˆè³ã€æ—¥æœ¬ãƒ€ãƒ¼ãƒ“ãƒ¼ã€èŠèŠ±è³ï¼‰ã¨ã€å„ãƒ¬ãƒ¼ã‚¹ã«å¯¾å¿œã™ã‚‹ãƒˆãƒ©ã‚¤ã‚¢ãƒ«ãƒ¬ãƒ¼ã‚¹3ã¤ã«å‹åˆ©ã™ã‚‹ã€‚',
                conditionEN: 'Win the three Triple Crown races (Satsuki Sho, Japan Derby, Kikka Sho) AND win one trial race for each.',
                check: () => this.checkPerfectCrown()
            },
            {
                id: 'perfect_tiara',
                nameJP: 'ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆãƒ†ã‚£ã‚¢ãƒ©',
                nameEN: 'Perfect Tiara',
                conditionJP: 'ç‰é¦¬ä¸‰å† ãƒ¬ãƒ¼ã‚¹ï¼ˆæ¡œèŠ±è³ã€ã‚ªãƒ¼ã‚¯ã‚¹ã€ç§‹è¯è³ï¼‰ã¨ã€å„ãƒ¬ãƒ¼ã‚¹ã«å¯¾å¿œã™ã‚‹ãƒˆãƒ©ã‚¤ã‚¢ãƒ«ãƒ¬ãƒ¼ã‚¹3ã¤ã«å‹åˆ©ã™ã‚‹ã€‚',
                conditionEN: 'Win the three Triple Tiara races (Oka Sho, Oaks, Akika Sho) AND win one trial race for each.',
                check: () => this.checkPerfectTiara()
            },
            {
                id: 'improves_with_racing',
                nameJP: 'å©ãè‰¯åŒ–å‹',
                nameEN: 'Improves with Racing',
                conditionJP: "3æˆ¦ä»¥ä¸Šã®é€£ç¶šå‡ºèµ°ã€‚'æ‚¦æ¥½å–æ'ã®è¨˜è€…ã‚¤ãƒ™ãƒ³ãƒˆå‡ºç¾ãŒå¿…è¦ï¼ˆç°¡ç•¥åŒ–æ¸ˆã¿ï¼‰",
                conditionEN: "Run 3 consecutive races; requires reporter event 'Pleasure Interview' (simplified)",
                check: () => this.checkImprovesWithRacing()
            },
            {
                id: 'never_give_up',
                nameJP: 'è«¦ã‚ãªã„å¿ƒ',
                nameEN: 'Never-Give-Up Spirit',
                conditionJP: 'ä¸€åº¦è² ã‘ã¦ã‹ã‚‰å‹åˆ©ã™ã‚‹ï¼ˆé †åºåˆ¤å®šã¯ç°¡ç•¥åŒ–ï¼‰ã€‚',
                conditionEN: 'Lose a race, then win a race (order simplified).',
                check: () => this.checkNeverGiveUp()
            },
            {
                id: 'right_awakening',
                nameJP: 'å³ã®ç›®è¦šã‚',
                nameEN: 'Right Awakening',
                conditionJP: 'å³å›ã‚Šã®ãƒ¬ãƒ¼ã‚¹ã§6å›ä»¥ä¸Šå‹åˆ©ã™ã‚‹ã€‚',
                conditionEN: 'Win 6 or more races on right-handed tracks.',
                check: () => this.checkDirectionalAwakening('right')
            },
            {
                id: 'left_awakening',
                nameJP: 'å·¦ã®ç›®è¦šã‚',
                nameEN: 'Left Awakening',
                conditionJP: 'å·¦å›ã‚Šã®ãƒ¬ãƒ¼ã‚¹ã§6å›ä»¥ä¸Šå‹åˆ©ã™ã‚‹ã€‚',
                conditionEN: 'Win 6 or more races on left-handed tracks.',
                check: () => this.checkDirectionalAwakening('left')
            },
            {
                id: 'spring_awakening',
                nameJP: 'æ˜¥ã®ç›®è¦šã‚',
                nameEN: 'Spring Awakening',
                conditionJP: 'æ˜¥ã®å­£ç¯€ã®ãƒ¬ãƒ¼ã‚¹ã§6å›ä»¥ä¸Šå‹åˆ©ã™ã‚‹ã€‚',
                conditionEN: 'Win 6 or more races during spring.',
                check: () => this.checkSeasonalAwakening('spring')
            },
            {
                id: 'summer_awakening',
                nameJP: 'å¤ã®ç›®è¦šã‚',
                nameEN: 'Summer Awakening',
                conditionJP: 'å¤ã®å­£ç¯€ã®ãƒ¬ãƒ¼ã‚¹ã§6å›ä»¥ä¸Šå‹åˆ©ã™ã‚‹ã€‚',
                conditionEN: 'Win 6 or more races during summer.',
                check: () => this.checkSeasonalAwakening('summer')
            },
            {
                id: 'autumn_awakening',
                nameJP: 'ç§‹ã®ç›®è¦šã‚',
                nameEN: 'Autumn Awakening',
                conditionJP: 'ç§‹ã®å­£ç¯€ã®ãƒ¬ãƒ¼ã‚¹ã§6å›ä»¥ä¸Šå‹åˆ©ã™ã‚‹ã€‚',
                conditionEN: 'Win 6 or more races during autumn.',
                check: () => this.checkSeasonalAwakening('autumn')
            },
            {
                id: 'winter_awakening',
                nameJP: 'å†¬ã®ç›®è¦šã‚',
                nameEN: 'Winter Awakening',
                conditionJP: 'å†¬ã®å­£ç¯€ã®ãƒ¬ãƒ¼ã‚¹ã§6å›ä»¥ä¸Šå‹åˆ©ã™ã‚‹ã€‚',
                conditionEN: 'Win 6 or more races during winter.',
                check: () => this.checkSeasonalAwakening('winter')
            }
        ];
    }

    setupEventListeners() {
        // Filter buttons
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                this.currentFilter = e.target.dataset.filter;
                this.renderRaces();
            });
        });

        // ESC key closes the picker modal (in addition to clicking outside)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                this.closePicker();
            } else if (e.key === 'ArrowLeft') {
                this.navigatePicker?.(-1);
            } else if (e.key === 'ArrowRight') {
                this.navigatePicker?.(1);
            }
        });
    }

	// =============================
	// Planner (game-style) UI
	// =============================
	createEmptyPlannerData() {
		const makeYear = () => {
			const cells = {};
			this.monthOrder.forEach(month => {
				this.halfOrder.forEach(half => {
					cells[this.cellKey(month, half)] = null; // single race or null
				});
			});
			return cells;
		};
		return { junior: makeYear(), classics: makeYear(), senior: makeYear() };
	}

	cellKey(month, half) { return `${month}|${half}`; }

	setPlannerYear(yearKey) {
		if (!['junior','classics','senior'].includes(yearKey)) return;
		this.plannerYear = yearKey;
		// Toggle active tab styles if present
		['tab-junior','tab-classics','tab-senior'].forEach(id => {
			const el = document.getElementById(id);
			if (!el) return;
			el.classList.remove('active');
		});
		const map = { junior: 'tab-junior', classics: 'tab-classics', senior: 'tab-senior' };
		const active = document.getElementById(map[yearKey]);
		if (active) active.classList.add('active');
		this.renderPlannerGrid();
	}

	clearPlannerYear() {
		const yearCells = this.plannerData[this.plannerYear];
		Object.keys(yearCells).forEach(k => { yearCells[k] = null; });
		this.syncSelectionsFromPlanner();
		this.renderPlannerGrid();
		this.renderRaces();
		this.updateProgress();
	}

		renderPlannerGrid() {
		const container = document.getElementById('planner-grid');
		if (!container) return; // older HTML may not have planner UI
		const yearCells = this.plannerData[this.plannerYear];
		const t = this.translations;
		const monthLabel = (m) => `${t.months[m] || m}`; // JP
		const halfLabel = (h) => `${t.halves[h] || h}`;   // JP
		const enShort = { January:'Jan', February:'Feb', March:'Mar', April:'Apr', May:'May', June:'Jun', July:'Jul', August:'Aug', September:'Sep', October:'Oct', November:'Nov', December:'Dec' };

		const slots = [];
		this.monthOrder.forEach(month => {
			this.halfOrder.forEach(half => {
				const key = this.cellKey(month, half);
					const rawValue = yearCells[key];
					const hasAnyForSlot = this.races.some(r => r.month === month && r.half === half && !!r[this.plannerYear]);
					const selectedId = (typeof rawValue === 'string' && rawValue) ? String(rawValue) : null;
					let slotBody = '';
					if (selectedId) {
						let r = this.raceById ? this.raceById.get(selectedId) : null;
						if (!r) {
							// Backward compatibility: previously stored race name
							r = this.races.find(rr => rr.name === selectedId) || null;
						}
						const hasLocal = r && r.image;
						const hasRemote = r && r.imageRemote;
						const bgLayers = [];
						if (hasLocal) bgLayers.push(`url('${r.image}')`);
						if (hasRemote) bgLayers.push(`url('${r.imageRemote}')`);
						const bgStyle = bgLayers.length ? `background-image: ${bgLayers.join(', ')}` : '';
						const badgeClass = this.lostRaces.has(selectedId) ? 'badge-lost' : (this.wonRaces.has(selectedId) ? 'badge-won' : '');
						slotBody = `
							<div class=\"slot-wrapper\"> 
								<button class=\"slot-button ${badgeClass}\" data-race-id=\"${selectedId}\" style=\"${bgStyle}\" onclick=\"tracker.openPicker('${month}','${half}')\"> 
									<div class=\"slot-gradient\"></div>
									<div class=\"slot-title\"> 
										<div class=\"en\">${r ? r.name : ''}</div>
										<div class=\"jp\">${r && r.nameJP ? r.nameJP : ''}</div>
									</div>
								</button>
								<button class=\"slot-remove\" title=\"Remove / å‰Šé™¤\" onclick=\"tracker.removeRaceFromPlanner('${month}','${half}')\">Ã—</button>
								<button class=\"loss-toggle-btn ${this.lostRaces.has(selectedId) ? 'lost' : 'won'}\" title=\"Toggle Win/Loss / å‹æ•—åˆ‡æ›¿\" style=\"position:absolute; top:6px; left:6px;\" onclick=\"tracker.toggleWinFromPlanner('${month}','${half}')\">${this.lostRaces.has(selectedId) ? 'ğŸ‘' : 'ğŸ†'}</button>
							</div>
						`;
					} else {
									slotBody = `<button class=\"planner-plus\" onclick=\"tracker.openPicker('${month}','${half}')\">ï¼‹ Add / è¿½åŠ </button>`;
					}
					const isSummer = (month === 'July' || month === 'August');
					slots.push(`
						<div class=\"planner-slot ${!selectedId && !hasAnyForSlot ? 'disabled' : ''} ${isSummer ? 'summer' : ''}\">
							<div class=\"planner-slot-head\"><span>${monthLabel(month)} ${halfLabel(half)} / <span class=\\"en\\">${enShort[month] || month} ${half}</span></span></div>
								<div class=\"planner-slot-body\">${slotBody || `<button class=\\"planner-plus ${hasAnyForSlot ? '' : 'disabled'}\\" ${hasAnyForSlot ? `onclick=\\"tracker.openPicker('${month}','${half}')\\"` : ''}>ï¼‹ Add / è¿½åŠ </button>`}</div>
						</div>
					`);
			});
		});
        container.innerHTML = slots.join('');
        this.syncProgressHeightToPlanner();
	}

	openPicker(month, half) {
		this.currentPicker = { year: this.plannerYear, month, half };
		const title = document.getElementById('picker-title');
		if (title) {
			const yearMap = { junior: 'ã‚¸ãƒ¥ãƒ‹ã‚¢ç´š', classics: 'ã‚¯ãƒ©ã‚·ãƒƒã‚¯ç´š', senior: 'ã‚·ãƒ‹ã‚¢ç´š' };
			title.textContent = `${yearMap[this.plannerYear]} â€” ${this.translations.months[month] || month} ${this.translations.halves[half] || half}`;
		}
        this.renderPickerList();
        const modal = document.getElementById('picker-modal');
        if (modal) modal.classList.remove('hidden');
        // Update toggle button state
        this.updateToggleButton();
        // Position side navs just outside the panel edges
        this.positionPickerNavs();
        // Setup swipe listeners
        this.attachPickerSwipeHandlers();
	}

	closePicker() {
		const modal = document.getElementById('picker-modal');
		if (modal) modal.classList.add('hidden');
	}

	toggleCloseOnSelection() {
		this.closeOnSelection = !this.closeOnSelection;
		this.updateToggleButton();
	}

	updateToggleButton() {
		const btn = document.getElementById('toggle-close-btn');
		if (btn) {
			const enText = btn.querySelector('.toggle-text-en');
			const jpText = btn.querySelector('.toggle-text-jp');
			if (this.closeOnSelection) {
				btn.classList.remove('active');
				if (enText) enText.textContent = 'Auto-close';
				if (jpText) jpText.textContent = 'è‡ªå‹•é–‰ã˜ã‚‹';
			} else {
				btn.classList.add('active');
				if (enText) enText.textContent = 'Stay open';
				if (jpText) jpText.textContent = 'é–‹ã„ãŸã¾ã¾';
			}
		}
	}

    onPickerBackdrop(evt) {
        // No longer needed, as backdrop has its own onclick to close.
        // Keeping for backward compatibility if still bound.
        if (!evt) return;
        const target = evt.target;
        if (target && (target.id === 'picker-modal' || target.classList.contains('picker-backdrop'))) {
            this.closePicker();
        }
    }

		renderPickerList() {
		const listEl = document.getElementById('picker-list');
		if (!listEl || !this.currentPicker) return;
		const { year, month, half } = this.currentPicker;
		const yearFlag = { junior: 'junior', classics: 'classics', senior: 'senior' }[year];
        const filtered = this.races.filter(r => r.month === month && r.half === half && (!!r[yearFlag]));
        const typeOrder = { 'GI': 0, 'GII': 1, 'GIII': 2, 'Open': 3, 'Pre-OP': 4 };
        const sorted = filtered.slice().sort((a, b) => {
            const ao = typeOrder[a.type] ?? 99;
            const bo = typeOrder[b.type] ?? 99;
            if (ao !== bo) return ao - bo;
            return (a.name || '').localeCompare(b.name || '');
        });
			const cellValue = this.plannerData[year][this.cellKey(month, half)];
        listEl.innerHTML = sorted.map(r => {
				const selected = String(cellValue) === String(r.id);
				const primary = r.image || r.imageRemote || '';
				const onerr = (r.image && r.imageRemote) ? `onerror=\"this.onerror=null; this.src='${r.imageRemote}'\"` : '';
				return `
					<div class=\"picker-item ${selected ? 'selected' : ''}\" data-race-id=\"${r.id}\" onclick=\"tracker.addRaceToCurrentCellById('${r.id}')\"> 
					<img src=\"${primary}\" alt=\"${(r.name || '').replace(/\\"/g, '&quot;')}\" ${onerr}>
					<div>
						<h4>${r.name}</h4>
						<div class=\"sub\">${r.nameJP || ''} ãƒ» ${r.type} ãƒ» ${r.length} ãƒ» ${r.racetrack}/${this.translations.tracks[r.racetrack] || r.racetrack}</div>
					</div>
				</div>
			`;
		}).join('');
	}

    navigatePicker(direction) {
        // direction: -1 (prev half) or 1 (next half). Wrap month/half within the same year.
        if (!this.currentPicker) return;
        const months = this.monthOrder;
        const halves = this.halfOrder; // ['1st','2nd']
        const yearOrder = ['junior','classics','senior'];
        let yi = yearOrder.indexOf(this.currentPicker.year);
        let mi = months.indexOf(this.currentPicker.month);
        let hi = halves.indexOf(this.currentPicker.half);
        const step = direction > 0 ? 1 : -1;
        hi += step;
        if (hi < 0) { hi = halves.length - 1; mi -= 1; }
        if (hi >= halves.length) { hi = 0; mi += 1; }
        if (mi < 0) { mi = months.length - 1; yi = (yi - 1 + yearOrder.length) % yearOrder.length; }
        if (mi >= months.length) { mi = 0; yi = (yi + 1) % yearOrder.length; }
        const year = yearOrder[yi];
        this.currentPicker = { year, month: months[mi], half: halves[hi] };
        // Update title and list
        const title = document.getElementById('picker-title');
        if (title) {
            const yearMap = { junior: 'ã‚¸ãƒ¥ãƒ‹ã‚¢ç´š', classics: 'ã‚¯ãƒ©ã‚·ãƒƒã‚¯ç´š', senior: 'ã‚·ãƒ‹ã‚¢ç´š' };
            title.textContent = `${yearMap[year]} â€” ${this.translations.months[this.currentPicker.month] || this.currentPicker.month} ${this.translations.halves[this.currentPicker.half] || this.currentPicker.half}`;
        }
        this.renderPickerList();
        this.positionPickerNavs();
    }

    attachPickerSwipeHandlers() {
        const panel = document.getElementById('picker-panel');
        if (!panel) return;
        let startX = 0, startY = 0, isTouch = false;
        const onTouchStart = (e) => {
            isTouch = true;
            const t = e.touches ? e.touches[0] : e;
            startX = t.clientX; startY = t.clientY;
        };
        const onTouchEnd = (e) => {
            if (!isTouch) return;
            const t = (e.changedTouches && e.changedTouches[0]) || e;
            const dx = t.clientX - startX;
            const dy = t.clientY - startY;
            if (Math.abs(dx) > 50 && Math.abs(dy) < 40) {
                this.navigatePicker(dx < 0 ? 1 : -1);
            }
            isTouch = false;
        };
        panel.onmousedown = onTouchStart;
        panel.onmouseup = onTouchEnd;
        panel.ontouchstart = onTouchStart;
        panel.ontouchend = onTouchEnd;
    }

    positionPickerNavs() {
        setTimeout(() => {
            const panel = document.getElementById('picker-panel');
            const leftBtn = document.querySelector('.picker-nav-left');
            const rightBtn = document.querySelector('.picker-nav-right');
            if (panel && leftBtn && rightBtn) {
                const rect = panel.getBoundingClientRect();
                const gap = 12; // distance from panel edge
                leftBtn.style.left = `${rect.left - leftBtn.offsetWidth - gap}px`;
                leftBtn.style.top = `${rect.top + rect.height / 2 - leftBtn.offsetHeight / 2}px`;
                rightBtn.style.left = `${rect.right + gap}px`;
                rightBtn.style.top = `${rect.top + rect.height / 2 - rightBtn.offsetHeight / 2}px`;
            }
        }, 0);
    }

    addRaceToCurrentCell(raceName) {
        // Backward-compat: resolve by name then delegate to ID-based handler
        const race = this.races.find(r => r.name === raceName);
        if (race) {
            return this.addRaceToCurrentCellById(String(race.id));
        }
        // If not found, keep prior behavior but store as string (unlikely now)
        if (!this.currentPicker) return;
        const { year, month, half } = this.currentPicker;
        const key = this.cellKey(month, half);
        const prev = this.plannerData[year][key];
        const id = String(raceName);
        this.plannerData[year][key] = id;
        if (prev && !this.isPlannedAnywhere(prev)) {
            this.selectedRaces.delete(prev);
            this.wonRaces.delete(prev);
            this.lostRaces.delete(prev);
        }
        this.selectedRaces.add(id);
        this.lostRaces.delete(id);
        this.wonRaces.add(id);
        if (this.closeOnSelection) this.closePicker();
        this.renderPlannerGrid();
        this.renderRaces();
        this.updateProgress();
    }

    addRaceToCurrentCellById(raceId) {
        if (!this.currentPicker) return;
        const id = String(raceId);
        const { year, month, half } = this.currentPicker;
        const key = this.cellKey(month, half);
        const prev = this.plannerData[year][key];
        this.plannerData[year][key] = id;
        if (prev && !this.isPlannedAnywhere(prev)) {
            this.selectedRaces.delete(prev);
            this.wonRaces.delete(prev);
            this.lostRaces.delete(prev);
        }
        this.selectedRaces.add(id);
        this.lostRaces.delete(id);
        this.wonRaces.add(id);
        if (this.closeOnSelection) this.closePicker();
        this.renderPlannerGrid();
        this.renderRaces();
        this.updateProgress();
    }

		removeRaceFromPlanner(month, half) {
		const key = this.cellKey(month, half);
			const prev = this.plannerData[this.plannerYear][key];
			this.plannerData[this.plannerYear][key] = null;
			// If previous race no longer exists in any planner cell, remove from global selections
			if (prev && !this.isPlannedAnywhere(prev)) {
				this.selectedRaces.delete(prev);
				this.wonRaces.delete(prev);
				this.lostRaces.delete(prev);
			}
		this.renderPlannerGrid();
		this.renderRaces();
		this.updateProgress();
	}

    toggleWinFromPlanner(month, half) {
			const key = this.cellKey(month, half);
            const id = this.plannerData[this.plannerYear][key];
            if (!id) return;
			// Cycle Won -> Lost -> Won
            this.toggleWinById(id);
		this.renderPlannerGrid();
	}

	syncSelectionsFromPlanner() {
		// Reconstruct global selections from planner (does not include manual grid selections)
			const planned = new Set();
			Object.values(this.plannerData).forEach(yearCells => {
				Object.values(yearCells).forEach(value => { if (value) planned.add(value); });
			});
		// Remove any selection not planned
		Array.from(this.selectedRaces).forEach(n => { if (!planned.has(n)) {
			this.selectedRaces.delete(n);
			this.wonRaces.delete(n);
			this.lostRaces.delete(n);
		}});
	}

    isPlannedAnywhere(raceId) {
			return Object.values(this.plannerData).some(yearCells => {
            return Object.values(yearCells).some(value => value === raceId);
			});
		}

    planRaceIntoPlanner(race, preferYear) {
        // Decide target year: prefer the active tab if applicable; otherwise the first truthy flag
        let targetYear = null;
        const flags = ['junior','classics','senior'];
        if (preferYear && race[preferYear]) targetYear = preferYear;
        if (!targetYear) {
            for (let i = 0; i < flags.length; i++) {
                if (race[flags[i]]) { targetYear = flags[i]; break; }
            }
        }
        if (!targetYear) targetYear = this.plannerYear;
        const key = this.cellKey(race.month, race.half);
        const prevId = this.plannerData[targetYear][key];
        this.plannerData[targetYear][key] = String(race.id);
        if (prevId && !this.isPlannedAnywhere(prevId)) {
            this.selectedRaces.delete(prevId);
            this.wonRaces.delete(prevId);
            this.lostRaces.delete(prevId);
        }
    }

    removeRaceEverywhereFromPlanner(raceId) {
        Object.keys(this.plannerData).forEach(yearKey => {
            const yearCells = this.plannerData[yearKey];
            Object.keys(yearCells).forEach(cellKey => {
                if (yearCells[cellKey] === raceId) yearCells[cellKey] = null;
            });
        });
    }

    renderRaces() {
        const grid = document.getElementById('races-grid');
        const filteredRaces = this.getFilteredRaces();
        
        grid.innerHTML = filteredRaces.map(race => `
            <div class="race-card ${this.selectedRaces.has(String(race.id)) ? 'selected' : ''} ${this.wonRaces.has(String(race.id)) ? 'won' : ''}" 
                 data-race-id="${race.id}" data-race="${race.name}" onclick="tracker.toggleParticipationById('${race.id}')">
                ${(() => {
                    const primary = race.image || race.imageRemote || '';
                    const fallback = race.image && race.imageRemote ? race.imageRemote : '';
                    if (!primary) return '';
                    const onerr = fallback ? `onerror=\"this.onerror=null; this.src='${fallback}'\"` : '';
                    return `<div class=\"race-thumb\"><img class=\"race-thumb-img\" src=\"${primary}\" alt=\"${(race.name || '').replace(/"/g, '&quot;')}\" loading=\"lazy\" ${onerr}></div>`;
                })()}
                <div class="race-name">
                    <div class="race-name-en">${race.name}</div>
                    <div class="race-name-jp">${race.nameJP}</div>
                </div>
                <div class="race-details">
                    <span class="race-grade grade-${race.type}">${race.type}</span>
                    ${race.length} â€¢ ${race.surface}/${this.translations.surfaces[race.surface] || race.surface}
                </div>
                <div class="race-details">
                    ${race.racetrack}/${this.translations.tracks[race.racetrack] || race.racetrack}
                    â€¢ ${this.translations.months[race.month] || race.month} ${this.translations.halves[race.half] || race.half} / ${race.month} ${race.half}
                    ${race.direction ? `â€¢ ${this.translations.directions[race.direction]} / ${race.direction}` : ''}
                </div>
                ${this.selectedRaces.has(String(race.id)) ? `
                <div class="win-button-container">
                    <button class="loss-toggle-btn ${this.lostRaces.has(String(race.id)) ? 'lost' : 'won'}" 
                            onclick="event.stopPropagation(); tracker.toggleWinById('${race.id}')">
                        ${this.lostRaces.has(String(race.id)) ? 'ğŸ‘' : 'ğŸ†'}
                    </button>
                </div>
                ` : ''}
            </div>
        `).join('');
        this.syncProgressHeightToPlanner();
    }

    getFilteredRaces() {
        let list;
        switch(this.currentFilter) {
            case 'GI': list = this.races.filter(r => r.type === 'GI'); break;
            case 'GII': list = this.races.filter(r => r.type === 'GII'); break;
            case 'GIII': list = this.races.filter(r => r.type === 'GIII'); break;
            case 'Open': list = this.races.filter(r => r.type === 'Open'); break;
            case 'Pre-OP': list = this.races.filter(r => r.type === 'Pre-OP'); break;
            case 'junior': list = this.races.filter(r => r.junior); break;
            case 'classic': list = this.races.filter(r => r.classics); break;
            case 'senior': list = this.races.filter(r => r.senior); break;
            case 'SSS': {
                const set = new Set(this.summerSeries?.sprint || []);
                list = this.races.filter(r => set.has(r.name));
                break;
            }
            case 'SMS': {
                const set = new Set(this.summerSeries?.mile || []);
                list = this.races.filter(r => set.has(r.name));
                break;
            }
            case 'S2000': {
                const set = new Set(this.summerSeries?.s2000 || []);
                list = this.races.filter(r => set.has(r.name));
                break;
            }
            case 'selected': list = this.races.filter(r => this.selectedRaces.has(String(r.id))); break;
            default: list = [...this.races];
        }
        const typeOrder = { 'GI': 0, 'GII': 1, 'GIII': 2, 'Open': 3, 'Pre-OP': 4 };
        return list.sort((a, b) => {
            const ao = typeOrder[a.type] ?? 99;
            const bo = typeOrder[b.type] ?? 99;
            if (ao !== bo) return ao - bo;
            const am = this.monthOrder.indexOf(a.month);
            const bm = this.monthOrder.indexOf(b.month);
            if (am !== bm) return am - bm;
            const halfOrder = { '1st': 0, '2nd': 1 };
            const ah = halfOrder[a.half] ?? 0;
            const bh = halfOrder[b.half] ?? 0;
            if (ah !== bh) return ah - bh;
            return (a.name || '').localeCompare(b.name || '');
        });
    }

    toggleParticipationById(raceId) {
        const id = String(raceId);
        if (this.selectedRaces.has(id)) {
            // Remove participation and clear all results
            this.selectedRaces.delete(id);
            this.wonRaces.delete(id);
            this.lostRaces.delete(id);
            // Also remove from planner wherever it appears
            this.removeRaceEverywhereFromPlanner(id);
        } else {
            // Add participation and automatically mark as won
            this.selectedRaces.add(id);
            this.wonRaces.add(id);
            // Also place into planner for the appropriate year/month/half
            const race = this.raceById.get(id);
            if (race) this.planRaceIntoPlanner(race, this.plannerYear);
        }
        this.renderRaces();
        this.renderPlannerGrid();
        this.updateProgress();
    }

    // Helpers to support name-based conditions while the authoritative state uses IDs
    getIdsForNames(nameList) {
        const result = new Set();
        (nameList || []).forEach(name => {
            const ids = this.raceIdsByName.get(name);
            if (ids) ids.forEach(id => result.add(id));
        });
        return result;
    }

    hasWonAnyByNames(nameList) {
        const ids = this.getIdsForNames(nameList);
        for (const id of ids) if (this.wonRaces.has(id)) return true;
        return false;
    }

    countWinsByFilter(predicate) {
        let count = 0;
        this.wonRaces.forEach(id => {
            const race = this.raceById.get(String(id));
            if (race && predicate(race)) count++;
        });
        return count;
    }

    toggleWinById(raceId) {
        const id = String(raceId);
        if (!this.selectedRaces.has(id)) return; // Can't win/lose if not participating
        
        // Toggle between Won and Lost
        if (this.wonRaces.has(id)) {
            // Currently won, change to lost
            this.wonRaces.delete(id);
            this.lostRaces.add(id);
        } else if (this.lostRaces.has(id)) {
            // Currently lost, change to won
            this.lostRaces.delete(id);
            this.wonRaces.add(id);
        }
        this.renderRaces();
        this.renderPlannerGrid();
        this.updateProgress();
    }

    clearAll() {
        const confirmed = confirm('This will clear all races in planner and database.\n\nã“ã‚Œã«ã‚ˆã‚Šã€ãƒ—ãƒ©ãƒ³ãƒŠãƒ¼ã¨ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®ã™ã¹ã¦ã®ãƒ¬ãƒ¼ã‚¹ãŒã‚¯ãƒªã‚¢ã•ã‚Œã¾ã™ã€‚\n\nAre you sure you want to continue?');
        if (!confirmed) return;

        this.selectedRaces.clear();
        this.wonRaces.clear();
        this.lostRaces.clear();
        // Also clear planner across all years
        Object.keys(this.plannerData).forEach(yearKey => {
            const cells = this.plannerData[yearKey];
            Object.keys(cells).forEach(k => { cells[k] = null; });
        });
        this.renderPlannerGrid();
        this.renderRaces();
        this.updateProgress();
    }

    updateProgress() {
        // Update stats
        document.getElementById('total-races').textContent = this.selectedRaces.size;
        document.getElementById('total-wins').textContent = this.wonRaces.size;
        document.getElementById('total-losses').textContent = this.lostRaces.size;
        
        // Check all hidden factors
        const results = this.hiddenFactors.map(factor => ({
            ...factor,
            result: factor.check()
        }));
        
        const completedCount = results.filter(r => r.result.completed).length;
        document.getElementById('completed-factors').textContent = completedCount;
        
        // Render hidden factors
        this.renderHiddenFactors(results);
        this.syncProgressHeightToPlanner();
    }

    syncProgressHeightToPlanner() {
        try {
            const planner = document.getElementById('planner-section');
            const panel = document.getElementById('progress-panel');
            if (!planner || !panel) return;
            const plannerHeight = planner.getBoundingClientRect().height;
            panel.style.maxHeight = `${plannerHeight}px`;
        } catch (err) {
            // ignore
        }
    }

    renderHiddenFactors(results) {
        const container = document.getElementById('hidden-factors');
        
        container.innerHTML = results.map(factor => {
            const statusClass = factor.result.completed ? 'completed' : 
                               factor.result.progress > 0 ? 'partial' : '';
            const progressPercentage = Math.min(100, (factor.result.current / factor.result.required) * 100);
            
            return `
                <div class="factor-item ${statusClass}">
                    <div class="factor-name">
                        <div class="factor-name-en">${factor.nameEN}</div>
                        <div class="factor-name-jp">${factor.nameJP}</div>
                        ${factor.result.completed ? '<div class="completion-badge">âœ…</div>' : ''}
                    </div>
                    <div class="factor-condition">
                        <div class="condition-en">${factor.conditionEN || factor.condition}</div>
                        ${factor.conditionJP ? `<div class="condition-jp">${factor.conditionJP}</div>` : ''}
                    </div>
                    <div class="factor-progress">
                        <div>Progress / é€²æ—: ${factor.result.current}/${factor.result.required}</div>
                        ${factor.result.details ? `<div style="margin-top: 2px; font-size: 0.75rem;">â€¢ ${factor.result.details}</div>` : ''}
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progressPercentage}%"></div>
                    </div>
                </div>
            `;
        }).join('');
    }

    // Planner-aware chronological helpers
    buildPlannerTimeline() {
        const cells = [];
        const yearOrder = ['junior','classics','senior'];
        try {
            yearOrder.forEach(year => {
                const yearCells = this.plannerData[year] || {};
                this.monthOrder.forEach(month => {
                    this.halfOrder.forEach(half => {
                        const key = this.cellKey(month, half);
                        const raw = yearCells[key];
                        const id = raw ? String(raw) : null;
                        const won = id ? this.wonRaces.has(id) : false;
                        const lost = id ? this.lostRaces.has(id) : false;
                        cells.push({ year, month, half, id, won, lost, filled: !!id });
                    });
                });
            });
        } catch (e) {
            // Fallback to empty timeline
        }
        return cells;
    }

    getMaxConsecutiveRunsFromPlanner() {
        const cells = this.buildPlannerTimeline();
        let max = 0, cur = 0;
        for (const c of cells) {
            if (c.filled) { cur += 1; } else { cur = 0; }
            if (cur > max) max = cur;
        }
        return max;
    }

    getMaxConsecutiveWinsFromPlanner() {
        const cells = this.buildPlannerTimeline();
        let max = 0, cur = 0;
        for (const c of cells) {
            if (c.won) { cur += 1; } else { cur = 0; }
            if (cur > max) max = cur;
        }
        return max;
    }

    hasLossThenWinFromPlanner() {
        const cells = this.buildPlannerTimeline();
        let seenLoss = false;
        for (const c of cells) {
            if (!c.filled) continue;
            if (c.lost) seenLoss = true;
            if (c.won && seenLoss) return true;
        }
        return false;
    }

    // Condition checking methods
    checkConsecutiveRuns() {
        // Enforce true consecutiveness using planner timeline
        const maxStreak = this.getMaxConsecutiveRunsFromPlanner();
        const required = 2;
        return {
            completed: maxStreak >= required,
            current: Math.min(maxStreak, required),
            required,
            progress: Math.min(100, (maxStreak / required) * 100),
            details: `Max planned consecutive runs: ${maxStreak}`
        };
    }
    checkConsecutiveWins() {
        // Enforce true consecutiveness using planner timeline
        const maxWinStreak = this.getMaxConsecutiveWinsFromPlanner();
        const required = 2;
        return {
            completed: maxWinStreak >= required,
            current: Math.min(maxWinStreak, required),
            required,
            progress: Math.min(100, (maxWinStreak / required) * 100),
            details: `Max planned consecutive wins: ${maxWinStreak}`
        };
    }

    checkEasternG1Wins() {
        const eastern = Array.from(this.wonRaces)
            .map(id => this.raceById.get(String(id)))
            .filter(race => race && this.isGradeOne(race) && this.easternTracks.includes(race.racetrack))
            .map(r => r.name);
        return {
            completed: eastern.length >= 7,
            current: eastern.length,
            required: 7,
            progress: (eastern.length / 7) * 100,
            details: `Eastern G1 wins: ${eastern.join(', ')}`
        };
    }

    checkWesternG1Wins() {
        const western = Array.from(this.wonRaces)
            .map(id => this.raceById.get(String(id)))
            .filter(race => race && this.isGradeOne(race) && this.westernTracks.includes(race.racetrack))
            .map(r => r.name);
        return {
            completed: western.length >= 7,
            current: western.length,
            required: 7,
            progress: (western.length / 7) * 100,
            details: `Western G1 wins: ${western.join(', ')}`
        };
    }

    checkDifferentRacecourses() {
        const racecourses = new Set();
        this.selectedRaces.forEach(id => {
            const race = this.raceById.get(String(id));
            if (race) racecourses.add(race.racetrack);
        });
        return {
            completed: racecourses.size >= 7,
            current: racecourses.size,
            required: 7,
            progress: (racecourses.size / 7) * 100,
            details: `Racecourses: ${Array.from(racecourses).join(', ')}`
        };
    }

    checkAllDistanceG1() {
        // CSV-aligned: any race win counts (not GI-restricted)
        const distanceWins = { short: false, mile: false, medium: false, long: false };
        Array.from(this.wonRaces).forEach(id => {
            const race = this.raceById.get(String(id));
            if (!race) return;
            Object.keys(distanceWins).forEach(category => {
                if (this.distanceCategories[category](race)) {
                    distanceWins[category] = true;
                }
            });
        });
        const completed = Object.values(distanceWins).every(won => won);
        const current = Object.values(distanceWins).filter(won => won).length;
        return {
            completed,
            current,
            required: 4,
            progress: (current / 4) * 100,
            details: `Categories won: ${Object.entries(distanceWins).filter(([k,v]) => v).map(([k,v]) => k).join(', ')}`
        };
    }

    checkNewspaperCups() {
        const names = ['Kyoto Shimbun Hai', 'Kobe Shimbun Hai', 'Chunichi Shimbun Hai', 'Tokyo Shimbun Hai'];
        const wonNames = names.filter(n => {
            const ids = this.raceIdsByName.get(n);
            if (!ids) return false;
            for (const id of ids) if (this.wonRaces.has(String(id))) return true;
            return false;
        });
        return {
            completed: wonNames.length >= 4,
            current: wonNames.length,
            required: 4,
            progress: (wonNames.length / 4) * 100,
            details: `Won: ${wonNames.join(', ')}`
        };
    }

    checkSummerSeries(seriesKey) {
        const targetNames = (this.summerSeries && this.summerSeries[seriesKey]) ? this.summerSeries[seriesKey] : [];
        const wonNames = targetNames.filter(n => {
            const ids = this.raceIdsByName.get(n);
            if (!ids) return false;
            for (const id of ids) if (this.wonRaces.has(String(id))) return true;
            return false;
        });
        return {
            completed: wonNames.length >= 3,
            current: wonNames.length,
            required: 3,
            progress: Math.min(100, (wonNames.length / 3) * 100),
            details: `Won: ${wonNames.join(', ')}`
        };
    }

    checkNewYearGold() {
        // Senior year, January, first half; must win Nakayama Kinen or Kyoto Kinen
        const targets = new Set(['Nakayama Kinen', 'Kyoto Kinen']);
        const qualified = [];
        this.wonRaces.forEach(id => {
            const race = this.raceById.get(String(id));
            if (!race) return;
            if (!targets.has(race.name)) return;
            if (race.senior && race.month === 'January' && race.half === '1st') qualified.push(race.name);
        });
        const unique = Array.from(new Set(qualified));
        return {
            completed: unique.length >= 1,
            current: unique.length,
            required: 1,
            progress: unique.length >= 1 ? 100 : 0,
            details: `Qualified wins: ${unique.join(', ')}`
        };
    }

    checkStarRaces() {
        const names = [
            'Procyon Stakes', 'Capella Stakes', 'Centaur Stakes', 'Aldebaran Stakes',
            'Rigel Stakes', 'Betelgeuse Stakes', 'Cassiopeia Stakes', 'Sirius Stakes'
        ];
        const wonNames = names.filter(n => {
            const ids = this.raceIdsByName.get(n);
            if (!ids) return false;
            for (const id of ids) if (this.wonRaces.has(String(id))) return true;
            return false;
        });
        return {
            completed: wonNames.length >= 3,
            current: wonNames.length,
            required: 3,
            progress: (wonNames.length / 3) * 100,
            details: `Won: ${wonNames.join(', ')}`
        };
    }

    checkJewelryRaces() {
        // Dataset-limited: only a subset available; CSV requires 3 distinct wins
        const names = ['Diamond Stakes', 'Turquoise Stakes', 'Opal Stakes'];
        const wonNames = names.filter(n => {
            const ids = this.raceIdsByName.get(n);
            if (!ids) return false;
            for (const id of ids) if (this.wonRaces.has(String(id))) return true;
            return false;
        });
        return {
            completed: wonNames.length >= 3,
            current: wonNames.length,
            required: 3,
            progress: Math.min(100, (wonNames.length / 3) * 100),
            details: `Won: ${wonNames.join(', ')}`
        };
    }

    checkDualSurface() {
        let turfWins = false;
        let dirtWins = false;
        this.wonRaces.forEach(id => {
            const race = this.raceById.get(String(id));
            if (!race) return;
            if (race.surface === 'turf') turfWins = true;
            if (race.surface === 'dirt') dirtWins = true;
        });
        const current = (turfWins ? 1 : 0) + (dirtWins ? 1 : 0);
        return {
            completed: turfWins && dirtWins,
            current,
            required: 2,
            progress: (current / 2) * 100,
            details: `Surfaces: ${turfWins ? 'Turf' : ''} ${dirtWins ? 'Dirt' : ''}`.trim()
        };
    }

    checkPerfectCrown() {
        const triple = ['Satsuki Sho', 'Japan Derby', 'Kikka Sho'];
        const groupA = ['Yayoi Sho', 'Spring Stakes', 'Wakaba Stakes'];
        const groupB = ['Aoba Sho', 'Principal Stakes'];
        const groupC = ['Kobe Shimbun Hai', 'Saint Lite Kinen'];
        const wonNamesSet = new Set(Array.from(this.wonRaces).map(id => {
            const r = this.raceById.get(String(id));
            return r ? r.name : null;
        }).filter(Boolean));
        const wonCrown = triple.filter(n => wonNamesSet.has(n));
        const groupAHit = groupA.some(n => wonNamesSet.has(n));
        const groupBHit = groupB.some(n => wonNamesSet.has(n));
        const groupCHit = groupC.some(n => wonNamesSet.has(n));
        const crownComplete = wonCrown.length === 3;
        const trialsComplete = groupAHit && groupBHit && groupCHit;
        const completed = crownComplete && trialsComplete;
        const wonTrialsList = [
            ...groupA.filter(n => wonNamesSet.has(n)),
            ...groupB.filter(n => wonNamesSet.has(n)),
            ...groupC.filter(n => wonNamesSet.has(n))
        ];
        return {
            completed,
            current: wonCrown.length + wonTrialsList.length,
            required: 6,
            progress: completed ? 100 : ((wonCrown.length + wonTrialsList.length) / 6) * 100,
            details: `Crown: ${wonCrown.join(', ')} | Trials A:${groupA.filter(n => wonNamesSet.has(n)).join('/')} B:${groupB.filter(n => wonNamesSet.has(n)).join('/')} C:${groupC.filter(n => wonNamesSet.has(n)).join('/')}`
        };
    }

    checkPerfectTiara() {
        const triple = ['Oka Sho', 'Oaks', 'Akika Sho'];
        const groupA = ['Fillies Review', 'Tulip Sho', 'Anemone Stakes'];
        const groupB = ['Flora Stakes', 'Sweet Pea Stakes'];
        const groupC = ['Rose Stakes', 'Shion Stakes'];
        const wonNamesSet = new Set(Array.from(this.wonRaces).map(id => {
            const r = this.raceById.get(String(id));
            return r ? r.name : null;
        }).filter(Boolean));
        const wonTiara = triple.filter(n => wonNamesSet.has(n));
        const groupAHit = groupA.some(n => wonNamesSet.has(n));
        const groupBHit = groupB.some(n => wonNamesSet.has(n));
        const groupCHit = groupC.some(n => wonNamesSet.has(n));
        const tiaraComplete = wonTiara.length === 3;
        const trialsComplete = groupAHit && groupBHit && groupCHit;
        const completed = tiaraComplete && trialsComplete;
        const wonTrialsList = [
            ...groupA.filter(n => wonNamesSet.has(n)),
            ...groupB.filter(n => wonNamesSet.has(n)),
            ...groupC.filter(n => wonNamesSet.has(n))
        ];
        return {
            completed,
            current: wonTiara.length + wonTrialsList.length,
            required: 6,
            progress: completed ? 100 : ((wonTiara.length + wonTrialsList.length) / 6) * 100,
            details: `Tiara: ${wonTiara.join(', ')} | Trials A:${groupA.filter(n => wonNamesSet.has(n)).join('/')} B:${groupB.filter(n => wonNamesSet.has(n)).join('/')} C:${groupC.filter(n => wonNamesSet.has(n)).join('/')}`
        };
    }

    checkImprovesWithRacing() {
        // Require 3 consecutive planned races (reporter event still simplified/unmodeled)
        const maxStreak = this.getMaxConsecutiveRunsFromPlanner();
        const required = 3;
        return {
            completed: maxStreak >= required,
            current: Math.min(maxStreak, required),
            required,
            progress: Math.min(100, (maxStreak / required) * 100),
            details: `Max planned consecutive runs: ${maxStreak} (reporter event not modeled)`
        };
    }

    checkNeverGiveUp() {
        // Enforce order: a loss occurs before a later win in planner timeline
        const cells = this.buildPlannerTimeline();
        const anyLoss = cells.some(c => c.lost);
        const anyWin = cells.some(c => c.won);
        const completed = this.hasLossThenWinFromPlanner();
        return {
            completed,
            current: completed ? 2 : (anyLoss || anyWin ? 1 : 0),
            required: 2,
            progress: completed ? 100 : (anyLoss || anyWin ? 50 : 0),
            details: completed ? 'Loss occurs before a later win (planner order)' : 'Need a loss followed by a later win (planner order)'
        };
    }

    checkRebelliousSpirit() {
        // Simplified: assume any win counts as this would require aptitude data
        const wonAny = this.wonRaces.size > 0;
        
        return {
            completed: wonAny,
            current: wonAny ? 1 : 0,
            required: 1,
            progress: wonAny ? 100 : 0,
            details: `Simplified: Any win counts (requires aptitude system)`
        };
    }

    checkDirectionalAwakening(direction) {
        const names = Array.from(this.wonRaces)
            .map(id => this.raceById.get(String(id)))
            .filter(r => r && r.direction === direction)
            .map(r => r.name);
        return {
            completed: names.length >= 6,
            current: names.length,
            required: 6,
            progress: (names.length / 6) * 100,
            details: `${direction}-handed wins: ${names.join(', ')}`
        };
    }

    checkSeasonalAwakening(season) {
        const names = Array.from(this.wonRaces)
            .map(id => this.raceById.get(String(id)))
            .filter(r => r && r.season === season)
            .map(r => r.name);
        return {
            completed: names.length >= 6,
            current: names.length,
            required: 6,
            progress: (names.length / 6) * 100,
            details: `${season} wins: ${names.join(', ')}`
        };
    }
}

// Initialize the tracker when the page loads
let tracker;
document.addEventListener('DOMContentLoaded', () => {
    tracker = new UmaMusumeTracker();
});